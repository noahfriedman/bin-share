#!/bin/sh
exec ${PERL-perl} -Swx $0 ${1+"$@"}
#!perl

# run-next --- run next instance of program in path after specified directory

# Author: Noah Friedman <friedman@splode.com>
# Created: 1995-09-07
# Public domain

# $Id: run-next,v 1.7 2000/08/10 10:02:42 friedman Exp $

# Commentary:

# This script can be used by front-end wrapper scripts in a user's personal
# path to set environment variables, manipulate args, etc. before calling
# the real program which resides in a directory specified somewhere later
# in the user's path.  For example, a front end to the mozilla browser
# could be written as:
#
#         #!/bin/sh
#         HOME=$HOME/etc/www/netscape
#         export HOME
#         exec run-next $0 ${1+"$@"}
#
# This script looks at the full path of the specified argument and will
# only search directories in PATH after that occurence.

# Code:

use 5.003;
use strict;
use Getopt::Long;

(my $progname = $0) =~ s|.*/||;
my $opt_print = 0;
my $opt_skip = 0;

sub usage
{
  print "Usage: $progname {options} [program {program options}]\n
Options are:
-h, --help                   You're looking at it.
-p, --print                  Just print full name of program to run,
                             without running it.  Any program options are
                             discarded.
-s, --skip           N       Run Nth instance of program in path.
                             This is relative to absolute pathname
                             specified in program name to run, if any.
                             Default is 1.\n";
  exit (1);
}

sub err
{
  my $fatalp = shift;
  my $msg = join (": ", $progname, @_);
  print STDERR $msg, (substr ($msg, -1, 1) eq "\n"? "" : "\n");
  exit (1) if $fatalp;
  return undef;
}

sub main
{
  Getopt::Long::config ('bundling', 'autoabbrev', 'require_order');
  GetOptions ("h|help",   \&usage,
              "p|print",  \$opt_print,
              "s|skip=i", \$opt_skip);

  my $arg = shift @ARGV;
  my ($progdir, $prog) = ($1, $2)
    if ($arg =~ m|^(.*)/([^/]*)$|);
  $progdir = "/" if (defined $progdir && $progdir eq "");
  $prog = $arg unless (defined $prog);

  my $found_progdir = defined $progdir ? 0 : 1;
  my %progdirs;
  my $seen = 0;
  my $execdir;
  my $dir;
  foreach $dir (split (/:/, $ENV{PATH}))
    {
      $dir = "." if ($dir eq "");

      if (!$found_progdir && $dir eq $progdir)
        {
          $found_progdir = 1;
          next;
        }
      next unless ($found_progdir);
      next if (exists $progdirs{$dir});
      my $f = join ("/", $dir, $prog);
      next unless (-x $f && -f $f);
      $progdirs{$dir} = $seen++;
      next unless ($seen > $opt_skip);
      $execdir = $dir;
      last;
    }

  err (1, $progdir, "directory not in PATH") unless ($found_progdir);
  err (1, $prog, "program not in any directories after \`$progdir' in PATH")
    if (scalar keys %progdirs == 0);
  if ($seen <= $opt_skip)
    {
      err (0, $prog, sprintf ("program does not appear in %d places, only %d:",
                              $opt_skip+1, $seen));
      map { err (0, "  " . join ("/", $_, $prog)) }
          sort { $progdirs{$a} <=> $progdirs{$b} } keys %progdirs;
      exit (1);
    }

  my $execprog = join ("/", $execdir, $prog);
  if ($opt_print)
    {
      print $execprog, "\n";
      exit (0);
    }

  exec ($execprog, @ARGV) || err (1, $execprog, "$!");
}

main ();

# local variables:
# mode: perl
# eval: (auto-fill-mode 1)
# end:

# run-next ends here
