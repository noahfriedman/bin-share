#! /bin/sh
# fmtcols --- indent columns so they line up

# Copyright (C) 1997, 2000 Noah S. Friedman

# Author: Noah Friedman <friedman@splode.com>
# Created: 1997-08-02

# $Id: fmtcols,v 2.2 2000/01/17 18:31:08 friedman Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.

# Commentary:
# Code:

exec ${PERL-perl} -Sx $0 ${1+"$@"}
#!perl

use Getopt::Long;
use strict;

use vars qw(@line @maxwidth %right_justify $fieldsep $width_limit);

sub read_input
{
  my $fieldsep = shift;
  my $fmtstr = "";

  while (<>)
    {
      chop;
      my @fields = split (/$fieldsep/o, $_, -1);
      push @line, $_;
      for (my $i = 0; $i <= $#fields; $i++)
        {
          $maxwidth[$i] = max (length ($fields[$i]), $maxwidth[$i]);
        }
    }
}

sub print_output
{
  my ($fieldsep, $width_limit) = @_;
  my $fmtstr = "";

  my $i = 0;
  while (defined $maxwidth[$i])
    {
      my $w = (defined $width_limit
               ? min ($maxwidth[$i], $width_limit)
               : $maxwidth[$i]);
      $fmtstr .= join ("",
                       (exists $right_justify{$i} ? "%" : "%-"),
                       $w,
                       (defined $width_limit ? "." . ($w-1) : ""),
                       "s ");
      $i++;
    }
  chop $fmtstr; # strip trailing whitespace

  $i = 0;
  while (defined $line[$i])
    {
      my $s = sprintf ($fmtstr, split (/$fieldsep/o, $line[$i], -1));
      $s =~ s/[ \t]+$//o;
      print $s, "\n";
      $i++;
    }
}

sub min { return [ sort {   $a <=> $b  } @_ ]->[0]; }
sub max { return [ sort { -($a <=> $b) } @_ ]->[0]; }

sub parse_options
{
  $fieldsep = "[ \t]+";
  $width_limit = undef;
  undef %right_justify;
  my @rightcols;

  Getopt::Long::config ('bundling', 'autoabbrev');
  GetOptions ("s|separator=s", \$fieldsep,
              "m|max-field-width=i", \$width_limit,
              "r|right-justify=s@", \@rightcols,
              "h|help", \&usage);

  for my $col (split (/\s*,\s*/o, join (",", @rightcols)))
    {
      $right_justify{$col} = 1;
    }
}

sub usage ()
{
  $0 =~ s|.*/||;
  print "Usage: $0 {options} [files {...}]\n
Options are:
-h, --help                      You're looking at it.
-r, --right-justify  F0,F1,...  Right-justify fields F0, F1, ...
-s, --separator      SEP        Field separator between columns.
                                This can be any regular expression.
                                The default field separator is any number of
                                tabs and spaces, i.e. \"[ \\t]+\".
-m, --max-field-width MAX       Truncate fields on output that are larger than
                                this limit.  By default, there is no limit.\n";
  exit (1);
}

sub main
{
  parse_options ();
  read_input ($fieldsep);
  print_output ($fieldsep, $width_limit);
}

main ();

# local variables:
# mode: perl
# eval: (auto-fill-mode 1)
# end:

# fmtcols ends here
