#!/bin/bash
# loadst, 18-Dec-91 Noah Friedman <friedman@prep.ai.mit.edu>
# Last modified 13-Oct-92
#
# A replacement for GNU loadst (which has reportedly been replaced
# with a different program in GNU Emacs 18.56. This shell script
# basically emulates loadst with the following differences: 
#    1) The number of mail messages pending is reported
#    2) Time is always given in 24-hour form.
#
# Requires bash version 1.12 or later to work properly. 
#
# Public domain.
#

function usage ()
{
    if [ $# -gt 0 ]; then
       echo -e "${progname}: $*\n" 1>&2
    fi

    cat 1>&2 <<EOF
Usage: ${progname} {-D} {-n} {-u} [delay]
EOF

   exit 1
}

function main ()
{
    initialize_variables "$@"
    parse_command_args "$@"
    shift $?

    test -n "${debug+set}" && set -x

    delay="$1"
    if ! numericp "${delay}" ; then
      usage "${bq}${delay}${eq}: interval argument should be numeric."
    fi

    if [ "${delay}" ]; then
       while : ; do 
          do_loadst; 
          sleep ${delay}
       done
    else
       do_loadst
    fi

}

function initialize_variables ()
{
    progname="${0##*/}"
    bq="\`"  # To prevent hairy quoting and escaping later.
    eq="'"

    timestamp="/tmp/${progname}$$"

    TRAP_SIGNALS="EXIT SIGHUP SIGINT SIGQUIT SIGTERM"
    trap 'cleanup_and_exit' ${TRAP_SIGNALS}
}

function parse_command_args ()
{
 local orig_number_options=$#
 local whoami_cmd="logname"

    # unset option variables to make sure they weren't accidentally
    # exported 
    unset newline debug

    # If you add new options be sure to change the wildcards below to make
    # sure they are unambiguous (i.e. only match one possible long option)
    # Be sure to show at least one instance of the full long option name to
    # document what the long option is canonically called. 
    # Long options which take arguments will need a `*' appended to the
    # canonical name to match the value appended after the `=' character. 
    while [ $# -gt 0 ]; do
       case z$1 in
          z-D | z--debug | z--d* )
             debug=t
             shift
            ;;
          z-n | z--no-newline | z--n* )
             newline="-n"
             shift
            ;;
          z-h* | z--help | z--h* )
             usage
            ;;
          z-u | z--use-euid | z--u* )
             whoami_cmd="whoami"
             shift
            ;;
          z-- )
             shift
             break
            ;;
          z-* )
             usage "${bq}${1}${eq} is not a valid option."
            ;;
          * )
             break
            ;;
       esac
    done

    user="${USER:-$(${whoami_cmd})}"
    mailfile="/usr/spool/mail/${user}"

    # Return number of shifted arguments so calling function can shift
    # appropriate amount.
    return $[ orig_number_options - $# ]
}

cleanup_and_exit ()
{
 local exitstat="$?"

   # Reset traps to avoid double execution of this function when a signal
   # is caught (as opposed to normal exit).
   trap '' ${TRAP_SIGNALS}

   rm -f "${timestamp}" 2> /dev/null

   builtin exit ${exitstat}
}

function logname () 
{ 
 local uname;

    uname="$(command logname 2> /dev/null)"
    echo "${uname:-$(command whoami)}"
}

# Returns zero exit status if argument consists entirely of numeric
# characters, nonzero otherwise.
function numericp ()
{
    case "${1}" in
       "" | *[!0-9]* )  
          return 1
         ;;
       *)
    esac

    return 0 
}

# A clever hack would be to run date once and parse it, then use bash's
# builtin $SECONDS variable to forever calculate the date afterward.  I
# guess it's not worth the bother, but it might save some exec overhead.
function do_loadst ()
{
 # Need GNU `date' for this to work
 #time="$(date +'%h %d  %H:%M')"
 
 #time=$(date | awk '{ split($4, time, ":");
 #                     printf( "%s %s  %s:%s\n", $2, $3, time[1], time[2] );
 #                   }')

 # Sed is usually faster than awk. 
 time=$(date | sed 's/.*\(... [0-9][0-9]* [0-9][0-9]*:[0-9][0-9]*\):.*/\1/')


 load=$(uptime | sed 's/.*load average:[ 	]*\([0-9.]*\).*/\1/')
 output="${time}  ${load}"


 mail=$(count_messages "${mailfile}" "${mail}")
 if [ "${mail}" != "0" ]; then
    output="${output} Mail:${mail}"
 fi

 echo ${newline} "${output}"
}

function count_messages ()
{
 local file="${1}"
 local oldmail="${2}"

    # If file isn't readable, or it's zero size, say it's zero in size. 
    if [ ! -r "${file}" -o ! -s "${file}" ]; then
      echo "0" 
      return
    fi

    # Create timestamp file if it's missing, and unset oldmail
    # value---various kinds of race conditions make it safest to just
    # recount the mail. 
    if [ ! -e "${timestamp}" ]; then
       touch "${timestamp}"
       oldmail="";
    fi

    # If file hasn't changed since timestamp was created and file has been
    # checked at least once before, return old number of messages.
    if [ "${timestamp}" -nt "${file}" -a -n "${oldmail}" ]; then
       echo "${oldmail}"
       return
    fi

    egrep "^From " ${file} | wc -l | sed "s/^[ 	]*//"
    touch "${timestamp}"

    return 0
}

main "$@"

# eof
