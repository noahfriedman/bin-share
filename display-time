#!/bin/sh
# display-time --- mode-line data accumulator for my time.el
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1991-12-18
# Public domain

# $Id: display-time,v 1.3 1994/04/20 16:04:02 friedman Exp $

# Commentary:
# Code:

# Name by which this script was invoked. 
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

# Substitute your usage string here. 
usage="Usage: $progname {options}

Options are;
-D, --debug                  Turn on shell debugging (${bq}set -x$eq).
-h, --help                   You're looking at it.
-l, --load-average           Print present load average.
-m, --mail                   Print number of spooled messages.
-s, --sleep SECONDS          Sleep SECONDS between each check.
"

# Usage: value=`(set - "$1" "$2"; eval "$get_option_argument")`
#
# Long option syntax is `--foo=bar' or `--foo bar'.  2nd argument ARG
# won't get used if first long option syntax was used. 
# If 3rd argument OPTIONAL is set, then 2nd may be empty without resulting
# in an error (i.e. option argument is optional)
#
# Returns number of positions caller should shift.
# If retval = 3, caller should exit.
get_option_argument='
  {
    option="$1" arg="$2" arg_optional="$3" shift_num=2
    case "$option" in
      --*=* )
        arg=`echo $option | sed -e "s/^[^=]*=//"` 
        shift_num=1
       ;;
    esac
    case "$arg" in
      "" )
        case "$arg_optional" in
          "" )
            case "$option" in 
              --*=* ) option=`echo $option | sed -e "s/=.*//"` ;;
            esac
            echo "$progname: option $bq$option$eq requires argument." 1>&2
            echo "$usage" 1>&2
            exit 3
           ;;
        esac
        exit 1
       ;;  
    esac
    echo "$arg"
    exit $shift_num
  }'

# Some bourne shells don't allow a numeric argument to `shift'.
# Usage: eval "shift_num=n; $shift_n_times"
shift_n_times='
  {
    while : ; do
      case "$shift_num" in 0 | "" ) break ;; esac
      shift_num=`expr $shift_num - 1`
      shift
    done
  }'

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
debug=
check_loadavg=
check_mail=
sleep_time=60

# Parse command line arguments. 
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character. 
while test $# != 0 ; do
  case "$1" in 
    -D | --debug | --d* )
      debug=t
      shift
     ;;
    -h | --help | --h* )
      echo "$usage" 1>&2
      exit 1
     ;;
    -l | --load-average | --l* )
      check_loadavg=t
      shift
     ;;
    -m | --mail | --m* )
      check_mail=t
      shift
     ;;
    -s | --sleep* | --s* )
      sleep_time=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    --*=* )
      arg=`echo $1 | sed -e 's/=.*//'`
      echo "$progname: unknown option $bq$arg$eq" 1>&2
      echo "$usage" 1>&2
      exit 1
     ;;
    -* )
      echo "$progname: unknown option $bq$1$eq" 1>&2
      echo "$usage" 1>&2
      exit 1
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in t ) set -x ;; esac

trap '{ 
        exitstat=$?
        rm -f "$stampfile" 2> /dev/null
        trap "" 1 2 3 15
        exit $exitstat
      }' 1 2 3 15

USER=${USER-${LOGNAME-`{ (whoami) 2> /dev/null; } \
                       || { id | sed -ne 's/.*uid=[0-9]*(//
                                          s/).*//
                                          p'
                          }`}}

for f in /usr/spool/mail /var/mail /usr/mail ; do
  if test -d "$f" ; then
    spoolfile="$f/$USER"
    break
  fi
done

stampfile="/tmp/$progname$$"
mail_result=

while : ; do
  loadavg_result=
  case "$check_loadavg" in t )
    loadavg=`uptime \
              | sed -ne 's/.*load average:[ 	]*//
                         s/[, 	].*//
                         p'`
    loadavg_result="loadavg:$loadavg"
   ;;
  esac
    
  if test ".$check_mail" = .t -a -s "$spoolfile" ; then
    set fnord `ls -td "$stampfile" "$spoolfile" 2> /dev/null` 
    shift
    case "$1" in "$spoolfile" )
      set fnord `grep '^From ' "$spoolfile" 2> /dev/null | wc -l`
      shift
      mail_result="mail:$1"
      > "$stampfile"
     ;;
    esac
  else
    mail_result=
  fi

  echo $loadavg_result $mail_result
  sleep "$sleep_time"
done

# display-time ends here
