#!/usr/local/gnubin/bash
# backup mail spool file into other files using movemail.
# Error reports can be sent to any arbitrary individual. 
#
# Requires bash version 1.12 or later, sendmail, gawk, and `movemail'
# program from the GNU Emacs distribution.
#
# 03-Apr-92 Noah Friedman <friedman@prep.ai.mit.edu>
# Last updated 03-Feb-93
# Public domain.
#

function usage ()
{
    if [ $# -gt 0 ]; then
       echo -e "${progname}: $*\n" 1>&2
    fi

    cat 1>&2 <<EOF
Usage: ${progname} {-d} {-t targets} {-e errors-recipient} {-u user} {-f file}
                   {--debug}
                   {--target-dirs=targets} 
                   {--errors-to=errors-recipient} 
                   {--user=user}
                   {--flag=file}

   "targets" is a colon-separated list of target directories. 

   If errors-to option is given, any output to stderr is mailed to the user
   specified as the argument to the errors-to option.  This is so that
   output from cron can be mailed to a user different from that run by
   cron.  Note that --errors-to should be the *first* thing specified on
   the command line, otherwise some stderr output may become lost (stderr
   isn't captured until this option is parsed)

   if flag option given, then the script won't do anything unless the file
   specified as an argument to --flag actually exists. 

   targets defaults to:          "${DEFAULT_TARGET_DIRS}"
   username defaults to:         (whoever runs the script)
EOF

   mail_errors
   exit 1
}

function main ()
{
    initialize_global_variables "$@"
    parse_command_args "$@"
    shift $?

    test -n "${debug+set}" && set -x

    # Only do something if enable_flag is undefined (i.e. no
    # existence-of-file condition has been set) or if the flag is set and
    # the file in question exists. 
    if [ \( ! "${enable_flag}" \) -o \( -e "${enable_flag}" \) ]; then
       move_mail
       mail_errors
    fi
}

function initialize_global_variables ()
{
    progname="${0##*/}"
    progname_arguments="$*"

    TRAP_SIGNALS="EXIT SIGHUP SIGINT SIGQUIT SIGTERM"
    trap 'cleanup_and_exit' ${TRAP_SIGNALS}

    # Be sure to include directories where `movemail' and `sendmail' are
    # located.
    PATH=/usr/local/lib/emacs/etc:/usr/local/bin:${PATH}:/usr/lib
    SPOOL_DIR="/usr/spool/mail"

    # Default target dirs (can be set with -t option on command line)
    DEFAULT_TARGET_DIRS='${HOME}'
    TARGET_DIRS="$(eval echo ${DEFAULT_TARGET_DIRS})"

    # Default user (can be overrident with -u option on command line)
    USER=${USER:-$(whoami)}

    # Define MAILHOST to be a host that will deliver mail (only useful if
    # current host where this script runs doesn't have a sendmail daemon)
    #MAILHOST=localhost

    bq="\`"  # To prevent hairy quoting and escaping later.
    eq="'"
}

function parse_command_args ()
{
 local orig_number_options=$#

    # unset option variables to make sure they weren't accidentally
    # exported 
    unset debug stderr_file enable_flag

    # If you add new commands be sure to change the wildcards below to make
    # sure they are unambiguous (i.e. only match one possible long option)
    # Be sure to show at least one instance of the full long option name to
    # document what the long option is canonically called. 
    while [ $# -gt 0 ]; do
       case z$1 in
          z-D | z--debug | z--d* )
             debug=t
             shift
            ;;
          z-e | z--errors-to* | z--e* )
             get_option_argument ERROR_REPORTS "$1" "$2"
             shift $?

             # Redirect all of stderr to a tmp file which we can mail
             # later. 
             stderr_file="/tmp/${progname}.$$"
             exec 2> "${stderr_file}"
            ;;
          z-f | z--flag* | z--f* )
             get_option_argument enable_flag "$1" "$2"
             shift $?
            ;;
          z-h | z--help | z--h* )
             usage
            ;;
          z-t | z--target-dirs* | z--t* )
             get_option_argument TARGET_DIRS "$1" "$2"
             shift $?
            ;;
          z-u | z--user* | z--u* )
             get_option_argument USER "$1" "$2"
             shift $?
            ;;
          z-- )
             shift
             break
            ;;
          z-* )
             usage "${bq}${1}${eq} is not a valid option."
            ;;
          * )
             break
            ;;
       esac
    done

    # Return number of shifted arguments so calling function can shift
    # appropriate amount.
    return $[ orig_number_options - $# ]
}

# Usage: get_option_argument VARIABLE OPTION ARG {OPTIONAL}
#    where VARIABLE is shell variable that will be set to the value ARG.
#    Long option syntax is `--foo=bar' or `--foo bar'.  3rd argument ARG
#    won't get used if first long option syntax was used.  If 4 arg
#    OPTIONAL is non-empty, option isn't required to have an argument; if
#    the argument is missing, VARIABLE is set to the empty value. 
# Returns number of positions caller should shift
function get_option_argument ()
{
 local variable="$1"
 local option="$2"
 local arg="$3"
 local arg_optional="$4"

    # All long options must be at least 3 characters long (--o*), whereas
    # short options are only two chars (-o) and arguments are always
    # separate.
    if [ ${#option} -ge 3 -a "z${option#*=}" != "z${option}" ]; then
       arg="${option#*=}"  # Strip off anything before and including `=' char
       eval ${variable}=\'"${arg}"\'
       return 1
    else
       if [ -z "${arg}" -a -z "${arg_optional}" ]; then
          usage "option ${bq}${option}${eq} requires argument."
       fi
       eval ${variable}=\'"${arg}"\'
       return 2
    fi
}

cleanup_and_exit ()
{
 local exitstat="$?"

   # Reset traps to avoid double execution of this function when a signal
   # is caught (as opposed to normal exit).
   trap '' ${TRAP_SIGNALS}

   if [ -n "${stderr_file}" ]; then
      rm -f "${stderr_file}"
   fi

   builtin exit ${exitstat}
}

move_mail ()
{
 local primary_dir
 local target_filename
 local spool_file="${SPOOL_DIR}/${USER}"

   # Move spool file to primary directory first using movemail
   if [ ! -f "${spool_file}" ]; then
      return 0
   fi

   primary_dir="$(set -- $(split_path ${TARGET_DIRS}); eval echo $1)"
   target_filename="$(unique ${USER}::$(current_date_time_string))"

   movemail "${spool_file}" "${primary_dir}/${target_filename}" 1>&2
   if [ $? -ne 0 ] ; then
      mail_errors
      exit 1
   fi

   # Now copy mail from primary target to all secondary targets
   # First shift just removes primary target dir from list. 
   set -- $(split_path ${TARGET_DIRS}); shift
   while [ $# -ne 0 ]; do
      # Expand path
      dir=$(eval echo $1);
      target="$(unique ${dir}/${target_filename})"
      cp "${primary_dir}/${target_filename}" "${target}"
      shift
   done
}

function split_path ()
{
 local p
 local IFS=':'

    set -- ${1}
    for p in "$@" ; do
       echo -n "${p:-.} "
    done
    echo 
}

function current_date_time_string ()
{
    awk 'BEGIN {
      "date" | getline date
      close("date")

      split(date, date_aref)
      year = substr(date_aref[6], 3);
      month = date_aref[2];
      nday = date_aref[3];
      # Pad date with extra zero if single-digit
      if (length(nday) == 1)
         nday = "0" nday;
      #time = substr(date_aref[4], 0, 5);
      time = date_aref[4];

      printf("%s-%s-%s__%s\n", year, month, nday, time);
    }'
}

# Generate a unique filename by appending a random number to name if
# necessary. 
function unique ()
{
 local file="$1"
 local newfile="${file}"

    while [ -e "${newfile}" ]; do
       newfile="${file}.${RANDOM}"
    done
   
    echo "${newfile}"
}

function mail_errors ()
{
    if [ ! "${stderr_file}" ]; then return 0; fi

    if [ -s "${stderr_file}" ]; then
       sendmail -oi -t <<- __EOF__
	From: ${USER} (${progname} script)
	To: ${ERROR_REPORTS}
	Subject: ${progname} stderr output
	Precedence: bulk
	
	This is an automated report.
	Program "${progname}" ran with the following arguments:
	
	"${progname_arguments}"
	
	and generated the following output on stderr:
	
	$(cat ${stderr_file})
	__EOF__
    fi
}

main "$@"

# eof
