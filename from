#! /bin/sh
# from --- show you who your mail is from

# Copyright (C) 1992, 1995, 1996, 1997, 1998 Noah S. Friedman

# Author: Noah Friedman <friedman@splode.com>
# Created: 1992-01-19

# $Id: from,v 1.27 1998/08/21 00:32:54 friedman Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.

# Commentary:

# The pop3 portions of this program strive to be compliant with RFC1939.
# Perl 5 is required.

# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"
bs='\'
dq='"'

# See if "\n" is interpreted by echo as a newline sequence.
x="`echo 'foo\nbar'`"
y='foo
bar'
if test "$x" = "$y"; then
  bs='\\'
fi

usage="Usage: $progname {options} {folder {...}}

Options are:
-1, --first-header-line      Do not display header continuation lines; show
                             only the first line of each displayed header.
-a, --all-headers            Show all headers.  Ignore $bq--format$eq.
-C, --count-only             Only count the number of messages that would
                             be displayed, without displaying any other
                             information about them.  E.g. $bq-Cu$eq would
                             print the number of unread messages you have.
-c, --columns       COLS     Truncate lines exceeding COLS length on output.
                             If COLS=0 or output is not to a terminal, no
                             truncation is done.  The default is
                             the current width of the terminal.
-D, --debug                  Enable interactive debugging.
-E, --extract      {LINES}   Print the body of each matched message.
                             If the optional argument LINES is supplied,
                             print only the first LINES number of lines.
-e, --envelope               Show message envelope instead of headers.
                             This causes any formatting options (e.g.
                             $bq--columns$eq, $bq--numbered$eq) to be ignored.
                             This option only makes sense for local folders.
-f, --format        FMT      Use FMT as the output format.  The option
                             $bq--help-format$eq gives instructions for this.
-h, --help                   You're looking at it.
-H, --help-format            Get documentation about the format of the FMT
                             argument to $bq--format$eq.
-M, --match-header  HEADERS  Seach only headers named HEADER for patterns
                             specified with $bq--match$eq.
                             By default, the header searched is ${bq}From$eq.
-m, --match         REGEXP   Only print messages in which REGEXP could be
                             found in the ${bq}From$eq header, or those
                             specified with $bq--match-headers$eq.
-n, --numbered               Show number of message with respect to the
                             current folder.  See also $bq--help-format$eq.
-s, --sender        ADDR     Show only messages sent from ADDR.
                             This is equivalent to specifying the options
                             $bq--match-headers=From --match=ADDR$eq.
-P, --no-parse               Do not do fancy parsing of From and Date fields.
-U, --user          USER     Show headers of USER's spooled messages.
-u, --unread-only            Only show information about unread messages
                             (i.e. those that do not have a ${bq}R$eq in
                             the Status header field).

It is possible to get headers for messages residing on POP3 servers.
To specify a POP3 folder, use the syntax $bq:pop3:host:username:password$eq
on the command line, or embed it in your MAIL environment variable.
"

format_usage="$progname format usage: --format='%{{-}{n}{.m}}[header] ...' ...

The FMT specifier to the $bq--format$eq option can contain literal text for
the output, along with header specifiers in the form

      %{{-}{n}{.m}}Header

where

  * ${bq}n$eq is the line width reserved for the value of ${bq}Header$eq.
  * $bq-$eq means that header strings shorter than ${bq}n$eq chars are
    flushed left within the field, instead of right.
  * $bq.m$eq is the maximum allowed length of the field; if the header
    string is longer than this, it is truncated.
  * ${bq}Header$eq is the name of the header, e.g. ${bq}Subject$eq.

Some special ${dq}header names$dq are defined for useful information that
cannot generally be obtained from message headers.  As usual, you can use
general format specifiers, e.g ${dq}%-4.3{TLINES}$dq.  These special names,
surrounded by curly braces, are:

  * $bq{TLINES}$eq
    The number of this message line irrespective of any folder it
    may have come from (if more than one folder was specified on the
    command line).
  * $bq{FLINES}$eq
    The number of this message in the current folder.  This number is reset
    whenever this program begins reading a new folder specified on the
    command line.
  * $bq{FOLDER}$eq
    The name of this folder, as specified on the command line.


For example, given a message with headers of the form

      From: Noah Friedman <friedman@splode.com>
      To: nobody@prep.ai.mit.edu
      Subject: example
      Date: Tue, 18 Oct 94 12:22:50 CDT

here are some valid format specifiers and the output that results from them.
($bq-|$eq indicates the results here; it is not actually printed.)

      ${dq}%From %Subject$dq
      -| Noah Friedman  example

      ${dq}%-19.18From %-13.12Date %-.45Subject$dq
      -| Noah Friedman       Oct 18 12:22  example

      ${dq}To %-19To %-13Date %20Subject$dq
      -| To nobody@prep.ai.mit.edu Oct 18 12:22                   example

      ${dq}To %-19.18To %-13.12Date %-.45Subject$dq
      -| To nobody@prep.ai.mit.  Oct 18 12:22  example

      ${dq}   From: %From${bs}nSubject: %Subject${bs}n   Date: %Date${bs}n$dq
      -|    From: Noah Friedman
      -| Subject: example
      -|    Date: Oct 18 12:22
      -|

If you use something like last example format specifier, you may wish to
use the $bq--no-parse$eq option to avoid any parsing (and therefore
truncation) of the From and Date lines.
"

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
FROMRC=${FROMRC-$HOME/.fromrc}
FROM_ALL_HEADERS_P=
FROM_COUNTP=
FROM_EXTRACTP=
FROM_LINELIMIT=
FROM_MATCH_HEADER=
FROM_MATCH_REGEXP=
FROM_FIRSTLINEP=
FROM_PARSEP=t
FROM_UNREAD_ONLY_P=
FROM_USER=$USER
FROM_NUMBERED=
debug=
envelopep=

# if stdout is not a tty, then disable truncation (user may explicitly
# enables it later by use of the --columns option).
if test -t 1; then
  # Decrement number of columns by 1 since output in last column causes
  # wraparound on many (most?) terminals.
  COLUMNS=`expr ${COLUMNS-80} - 1`
else
  COLUMNS=0
fi

# Precedence for defs (highest->lowest): options, ~/.fromrc, default
if test -f "$FROMRC"; then
  . "$FROMRC"
fi

# Usage: eval "$getopt"; value=$optarg
# or     optarg_optional=t; eval "$getopt"; value=$optarg
#
# This function automatically shifts the positional args as appropriate.
# The argument to an option is optional if the variable `optarg_optional'
# is non-empty.  Otherwise, the argument is required and getopt will cause
# the program to exit on an error.  optarg_optional is reset to be empty
# after every call to getopt.  The argument (if any) is stored in the
# variable `optarg'.
#
# Long option syntax is `--foo=bar' or `--foo bar'.
# For optional args, you must use the `--foo=bar' long option syntax
# if the argument starts with `-', otherwise the argument will be ignored
# and treated as the next option.
#
# Note: because of a bourne shell misfeature, using --foo=bar syntax can
# actually screw the quoting of args that end with trailing newlines.
# Specifically, most shells strip trailing newlines from substituted
# output, regardless of quoting.
getopt='
  {
    optarg=
    case "$1" in
      --*=* ) optarg=`echo "$1" | sed -e "1s/^[^=]*=//"` ; shift ;;
      -* )
        case "${2+set}:$optarg_optional" in
          set: ) optarg="$2" ; shift ; shift ;;
          set:?* )
            case "$2" in
              -* ) shift ;;
              * )  optarg="$2"; shift; shift ;;
            esac
           ;;
          : )
            option="$1"
            case "$option" in
              --*=* ) option=`echo "$option" | sed -e "1s/=.*//;q"` ;;
            esac
            echo "$progname: option $bq$option$eq requires argument." 1>&2
            echo "$progname: use $bq--help$eq to list option syntax." 1>&2
            exit 1
           ;;
          * ) shift ;;
        esac
       ;;
    esac
    optarg_optional=
  }'

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while : ; do
  case $# in 0) break ;; esac
  case "$1" in
    -1 | --first-header-line-only | --fi* )
      FROM_FIRSTLINEP=t
      shift
     ;;
    -a | --all-headers | --a* )
      FROM_ALL_HEADERS_P=t
      shift
     ;;
    -C | --count-only | --cou* )
      FROM_COUNTP=t
      shift
     ;;
    -c | --columns* | --col* )
      eval "$getopt"
      COLUMNS=$optarg
     ;;
    -D | --debug | --d* )
      debug=-d
      shift
     ;;
    -E | --extract* | --ex* )
      FROM_EXTRACTP=t
      optarg_optional=t
      eval "$getopt"
      case "$optarg" in
        '' ) : ;;
        *  ) FROM_LINELIMIT="$optarg" ;;
      esac
     ;;
    -e | --envelope | --en* )
      envelopep=t
      shift
     ;;
    -f | --format* | --f* )
      eval "$getopt"
      FROM_FORMAT="$optarg"
     ;;
    -H | --help-format | --help-* )
      echo "$format_usage" 1>&2
      exit 1
     ;;
    -h | --help | --h* )
      echo "$usage" 1>&2
      exit 1
     ;;
    -M | --match-header* | --match-h* )
      eval "$getopt"
      FROM_MATCH_HEADER="$optarg"
     ;;
    -m | --match* )
      eval "$getopt"
      FROM_MATCH_REGEXP="$optarg"
     ;;
    -n | --numbered | --n* )
      FROM_NUMBERED=t
      shift
     ;;
    -P | --no-parse | --n* )
      FROM_PARSEP=
      shift
     ;;
    -s | --sender* | --s* )
      # This option is for compatibility with Brian Fox's implementation.
      eval "$getopt"
      FROM_MATCH_REGEXP="$optarg"
      FROM_MATCH_HEADER=From
     ;;
    -U | --user* | --us* )
      eval "$getopt"
      FROM_USER="$optarg"
     ;;
    -u | --unread-only | --un* )
      FROM_UNREAD_ONLY_P=t
      shift
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -? | --* )
      case "$1" in
        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
        * )     arg="$1" ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    -??* )
      # Split grouped single options into separate args and try again
      optarg="$1"
      shift
      set fnord `echo "x$optarg" | sed -e 's/^x-//;s/\(.\)/-\1 /g'` ${1+"$@"}
      shift
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in -d ) set -x ;; esac

case $# in
  0 )
    if test ".$FROM_USER" != ".$USER" || test "${MAIL-unset}" = "unset"; then
      USER=${USER-${LOGNAME-`{ id | sed -ne 's/.*uid=[0-9]*(//
                                             s/).*//
                                             p'
                             } \
                             || { (whoami) 2> /dev/null; }`}}

      spooldirs='
        /var/mail
        /var/spool/mail
        /usr/spool/mail
        /usr/mail
        /com/mail
      '

      MAIL=
      for f in $spooldirs ; do
        if test -f "$f/$USER" ; then
          MAIL="$f/$USER"
          break
        fi
      done

      case "$MAIL" in
        '' ) exit 1 ;;
      esac
    fi

    set fnord "$MAIL" ${1+"$@"}
    shift
   ;;
esac

perl="${FROM_PERL-${PERL-perl}}"

# Use quick grep only if no more complicated parsing need be done.
case "$envelopep:$FROM_EXTRACTP$FROM_MATCHP$FROM_UNREAD_ONLY_P" in
  't:' )
    case "$FROM_COUNTP" in
       '') exec sed -n -e '/^From /p' ${1+"$@"} ;;
       t )
         exec $perl -e '$! = 0; while (<>) { /^From /o && $n++; }' \
                    -e '$! && exit $!;' \
                    -e 'print "$n\n";' \
                    ${1+"$@"}
        ;;
    esac
  ;;
esac

case "${FROM_FORMAT+set}" in
  set ) : ;;
  * )
    case "$FROM_EXTRACTP" in
      t )
        FROM_PARSEP=
        for h in From To Cc Subject Date ; do
          FROM_FORMAT="${FROM_FORMAT}$h: %$h\n"
        done
       ;;
      * )
        FROM_FORMAT='%-19.18From %-13.12Date %Subject\n'

        case "$FROM_NUMBERED" in
          t )
            FROM_FORMAT="%-3{FLINES} $FROM_FORMAT"
           ;;
        esac
       ;;
    esac
   ;;
esac

FROM_PROGNAME=$progname

export FROM_PROGNAME COLUMNS
export FROM_ALL_HEADERS_P FROM_COUNTP FROM_EXTRACTP FROM_FIRSTLINEP
export FROM_PARSEP FROM_UNREAD_ONLY_P FROM_LINELIMIT FROM_MATCH_HEADER
export FROM_MATCH_REGEXP FROM_FORMAT FROM_USER
export MAIL POPPASS

# By using a here-document to include the source of the perl script (to
# avoid command line length limits), we usurp the normal stdin the inferior
# process might have expected.  So dup stdin onto fd 9, and before the
# inferior process is started, it will be reduped back onto fd 0.
exec $perl $debug - ${1+"$@"} 9<&0 <<'__EOF__'

&main;

sub main
{
  local ($i) = 0;

  $from_progname = &getenv ('FROM_PROGNAME');

  # See comments preceding perl invocation for an explanation.
  if (! open (STDIN, "<&9"))
    {
      &err ("cannot recover stdin from fd 9", "$!");
      exit (1);
    }

  # There's no clean way to close this file descriptor.  Way to go, Larry.
  #close (9);

  &initialize_variables ();
  &make_format_vector (&getenv ("FROM_FORMAT"));

  $header_save_p{'STATUS'} = 1
    if ($unread_only_p);

  if ($from_match_header ne '')
    {
      # Must store actual header name as well as MATCH header name, so that
      # contents will be stored.
      $header_save_p{"\U$from_match_header"} = 1;
      $from_match_header = "{MATCH_\U$from_match_header}";
      $header_save_p{$from_match_header} = 1;
    }

  $i = 0;
  foreach $file (@ARGV)
    {
      if ($file !~ /^:pop/oi
          && $file ne "-"
          && ! -r $file)
        {
          # Set $! appropriately.
          open (F, "<$file");
          &err ("$file", "$!.");
          close (F);

          splice (@ARGV, $i, 1);
          $exit_status = 1;
        }
      $i++;
    }

  foreach $file (@ARGV)
    {
      if ($file =~ /^:(pop3|pop-3|pop):/oi)
        {
          local ($ignore, $port, $host, $user, $pass) = split (/:/, $file);

          if (! defined ($user) || $user eq '')
            {
              foreach $envvar ('USER', 'LOGNAME')
                {
                  if (defined ($ENV{$envvar}))
                    {
                      $user = $ENV{$envvar};
                      last;
                    }
                }
            }

          if (! defined ($pass) || $pass eq '')
            {
              $pass = &getenv ('POPPASS');
              $pass = 'none'
                if (! defined ($pass));
            }

          &process_pop3_folder ($host, $port, $user, $pass);
        }
      else
        {
          &process_file ($file);
        }
    }
  exit ($exit_status);
}

sub initialize_variables
{
  $t = 1;
  $nil = 0;

  $ctime_now = &my_ctime ();

  @month_conv = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec');

  # This is perhaps a little too specific, but some MTAs do not
  # quote 'From ' at the beginning of a line in the body, especially
  # when writing to archive files.
  # The amount of whitespace between the address and the date seems to vary
  # on some systems.
  $re_message_delimiter = '^From[ \t]+[^ \t]+[ \t]+... ... .. ..:..';

  # According to RFC822, "The field-name must be composed of printable
  # ASCII characters (i.e. characters that have decimal values between 33
  # and 126, except colon)", i.e. any chars except ctl chars, space, or colon.
  $re_header_name = '[][!"#$%&\'()*+,-./0-9;<=>?@A-Z\\^_`a-z{|}~]+';

  # However, these are the characters allowed in FROM_FORMAT specifier
  # header names; some restrictions exist for the sake of formatting.
  $re_fmt_header_name = '[!"#$&\'*+,-./0-9;<=>?@A-Z\\^_`a-z{|}~]+';

  $re_whitespace = "[ \f\n\r\t]+";
  $re_blank_line = '(^' . $re_whitespace . '$)|(^$)';
  $re_format_modifier = '%[0-9.-]*';

  $hack_header_function{'FROM'} = 'hack_From_data';
  $hack_header_function{'DATE'} = 'hack_Date_data';

  $format_token{'{TLINES}'} = 'd';
  $format_token{'{FLINES}'} = 'd';

  $all_headers_p            = &truep ('FROM_ALL_HEADERS_P');
  $hack_data_p              = &truep ('FROM_PARSEP');
  $extract_body_p           = &truep ('FROM_EXTRACTP');
  $unread_only_p            = &truep ('FROM_UNREAD_ONLY_P');
  $count_only_p             = &truep ('FROM_COUNTP');
  $first_header_line_only_p = &truep ('FROM_FIRSTLINEP');

  $total_message_lines = 0;
  $in_message_body_p = $nil;
  $exit_status = 0;

  $columns           = &getenv ('COLUMNS');
  $from_match_header = &getenv ('FROM_MATCH_HEADER');
  $from_match_regexp = &getenv ('FROM_MATCH_REGEXP');

  $body_line_limit = 0;
  if (&getenv ('FROM_LINELIMIT') ne '')
    {
      $body_line_limit = &getenv ('FROM_LINELIMIT') + 0;
    }
  elsif ($extract_body_p)
    {
      $body_line_limit = -1;
    }
}

sub make_format_vector
{
  local ($format) = @_;
  local ($fstring, $tmp, $i, $modifier, $tok) = ($format, '', 0);
  local ($re_token) = "$re_format_modifier" . "[^%]*";

  undef (%header_save_p);
  undef (%vector_header_name);
  undef (@format_vector);

  # Here we temporarily disable multi-line scanning ($* = 0) and do not use
  # /(re)|(re)/, but rather use two pattern matching comparisons.  This is
  # because otherwise perl will use ^ to match the beginning of any line,
  # not just the beginning of the string.  What a pain.
  $* = 0;
  while ($fstring =~ /^[^%]+/o || $fstring =~ /^%%/o)
    {
      $tmp = $tmp . $&;
      $fstring = $';
    }
  $* = 1;

  $vector_header_name[0] = 'prefix';
  $format_vector[0] = $tmp;

  while ($fstring =~ /^$re_token/o)
    {
      $i++;
      $modifier = "";
      $tmp = $&;
      $fstring = $';

      if ($tmp =~ /$re_format_modifier/o)
        {
          $modifier = $&;
          $tmp = $';
          if ($tmp =~ /$re_fmt_header_name/o)
            {
              $tmp = $&;
              $trailing_whitespace = $';
            }
          else
            {
              $trailing_whitespace = "";
            }
        }

      $* = 0;
      while ($fstring =~ /^[^%]+/o || $fstring =~ /^%%/o)
        {
          $trailing_whitespace = $trailing_whitespace . $&;
          $fstring = $';
        }
      $* = 1;

      # Make header name all upper case to distinguish from extraneous data
      # like the `prefix' element.
      $tmp = "\U$tmp";

      if (defined ($format_token{$tmp}))
        {
          $tok = $format_token{$tmp};
        }
      else
        {
          $tok = 's';
        }

      $header_save_p{$tmp} = 1;
      $vector_header_name[$i] = $tmp;
      $format_vector[$i] = $modifier . $tok . $trailing_whitespace;
    }
}

sub process_file
{
  local ($file) = @_;
  local ($header_contents) = "";
  local (@all_headers);
  local ($all_headers_count) = 0;

  if (! open (F, "<$file"))
    {
      &err ("open", $file, "$!");
      return;
    }

  $folder_message_lines = 0;
  $counted_messages = 0;
  $in_message_body_p = $t;

  while (<F>)
    {
      chop $_;

      # If we hit an RFC822 message delimiter, clean up in preparation for
      # getting info about the next message.
      if ($in_message_body_p && $_ =~ /$re_message_delimiter/o)
        {
          undef (@all_headers);
          $all_headers_count = 0;

          undef (%current_headers);
          undef ($header_contents);
          $in_message_body_p = $nil;
          next;
        }

      # If we're finished reading header continuation line (evidenced by
      # coming upon a new header name), finish processing this header.
      if (defined ($header_contents) && $_ =~ /^$re_header_name/o)
        {
          $all_headers[$all_headers_count++] = $header_contents
            if ($all_headers_p);
          &add_header ($header_contents);
          $header_contents = $_;
          next;
        }

      # If we're not in the message body, and we come upon a blank line,
      # we're at the end of the headers for this message.
      if (! $in_message_body_p && $_ =~ /$re_blank_line/o)
        {
          # Add last buffered header.
          $all_headers[$all_headers_count++] = $header_contents
            if ($all_headers_p);
          &add_header ($header_contents);
          undef ($header_contents);

          $total_message_lines++;
          $folder_message_lines++;
          $current_headers{'{TLINES}'} = $total_message_lines;
          $current_headers{'{FLINES}'} = $folder_message_lines;
          $current_headers{'{FOLDER}'} = $file;

          $in_message_body_p = $t;
          $body_line_count = 0;

          if ($all_headers_p)
            {
              &maybe_print_headers ($all_headers_count, \@all_headers);
            }
          else
            {
              &maybe_print_headers ();
            }
        }

      if ($in_message_body_p)
        {
          if ($extract_body_p
              && ! $ignore_this_message_p
              && (($body_line_limit < 0)
                  || ($body_line_count <= $body_line_limit)))
            {
              print "$_\n";
              $body_line_count++;
            }
          next;
        }

      # Otherwise, append current header info.
      if (! defined ($header_contents))
        {
          $header_contents = $_;
        }
      elsif (! $first_header_line_only_p)
        {
          $header_contents .= "\n$_";
        }
    }

  print "$counted_messages\n"
    if ($count_only_p);
  close (F);
}

sub process_pop3_folder
{
  local ($host, $port, $user, $pass) = @_;
  local ($total_message_count, $msgnumber);

  &initialize_sockvars;
  &tcpconnect ($host, $port) || return 0;
  &pop3_login ($user, $pass) || return 0;

  $total_message_count = &pop3_message_count;

  if ($count_only_p && ! $unread_only_p)
    {
      &pop3_close;
      print "$total_message_count\n";
      return 1;
    }

  $current_headers{'{FOLDER}'} = "$host:$port:$user";
  $folder_message_lines = 0;
  $counted_messages = 0;
  $msgnumber = 1;

  while ($msgnumber <= $total_message_count)
    {
      local ($lines);
      local ($lineno) = 0;

      if ($extract_body_p
          && $from_match_header ne ''
          && $body_line_limit != 0)
        {
          # If we're searching for a particular message for extraction, get
          # just the headers first to see if this is a matching message.
          # Then and only then should we try retrieving the body below.
          &process_pop3_folder_get ($msgnumber, 0);
          if (! &message_header_pattern_matched_p ())
            {
              $msgnumber++;
              $total_message_lines++;
              next;
            }
        }

      ($lineno, $lines)
        = &process_pop3_folder_get ($msgnumber, $body_line_limit);
      $total_message_lines++;
      $current_headers{'{FLINES}'} = $msgnumber;
      $current_headers{'{TLINES}'} = $total_message_lines;

      if ($all_headers_p)
        {
          &maybe_print_headers ($lineno, $lines);
        }
      else
        {
          &maybe_print_headers ();
        }

      if (! $ignore_this_message_p && $extract_body_p)
        {
          while (defined (${$lines}[$lineno]))
            {
              print "${$lines}[$lineno]\n";
              $lineno++;
            }
          print "\n" if ($body_line_limit != 0);
        }

      $msgnumber++;
    }
  &pop3_close;
}

sub process_pop3_folder_get
{
  local ($msgnumber, $body_line_limit) = @_;
  local ($lineno) = 0;
  local ($header_line_count, $lines)
    = &pop3_retrieve_lines ($msgnumber, $body_line_limit);
  local ($header_contents) = '';

  undef (%current_headers);

  while ($lineno < $header_line_count)
    {
      if ($header_contents ne ''
          && ${$lines}[$lineno] =~ /^$re_header_name/o)
        {
          &add_header ($header_contents);
          $header_contents = ${$lines}[$lineno];
        }
      else
        {
          $header_contents .= "\n${$lines}[$lineno]"
            if ($header_contents eq '' || ! $first_header_line_only_p);
        }
      $lineno++;
    }

  # Add last buffered header.
  &add_header ($header_contents);
  return ($lineno, $lines);
}

# This uses way, way too many free variables
sub maybe_print_headers
{
  # $lines should be a reference to an array of lines.
  local ($lines_header_end, $lines) = @_;

  $ignore_this_message_p = $t;

  if (! ($unread_only_p
         && $current_headers{'STATUS'} =~ /[Rr]/o)
      && &message_header_pattern_matched_p () )
    {
      $counted_messages++;
      $ignore_this_message_p = $nil;
      if (! $count_only_p)
        {
          if ($extract_body_p)
            {
              printf ("From ----------Message-%.3d---------- %s\n",
                      $total_message_lines, $ctime_now);
            }

          if (defined ($lines_header_end))
            {
              local ($l) = 0;
              print "${$lines}[$l++]\n"
                while ($l < $lines_header_end);
            }
          else
            {
              &print_headers ();
            }
        }
    }
}


sub add_header
{
  local ($line) = @_;
  local ($header, $data);

  if (! ($line =~ /^[^ :]*: /o))
    {
      return;
    }

  $header = "\U$&";
  # Get rid of trailing `: ';
  substr ($header, -2) = '';

  if (defined ($header_save_p{$header}))
    {
      $data = $';

      # Store the unparsed header data in the match_header, if defined.
      $current_headers{$from_match_header} = $data
        if ("{MATCH_$header}" eq $from_match_header);

      if ($hack_data_p && defined ($hack_header_function{$header}))
        {
          local ($fn) = $hack_header_function{$header};
          $data = &$fn ($data);
        }

      $current_headers{$header} = $data;
    }
}

# Try to extract real name from From: line when possible
sub hack_From_data
{
  local ($data) = @_;

  # From: foobar@host (real name)
  # From: "real name" <foobar@host>
  if ($data =~ /\([^\)]+\)|(\"[^\"]+\")/o)
    {
      $data = $&;
      # Delete leading and trailing name delimiters (quotes or parens)
      substr ($data, 0, 1) = '';
      substr ($data, -1) = '';
    }
  # From: "" <foobar@host>
  elsif ($data =~ /\"\"[^<]*<[^>]+>/o)
    {
      $data =~ /"<[^>]+>"/;
      $data = $&;
      substr ($data, 0, 1) = '';
      substr ($data, -1) = '';
    }
  # From: real name <foobar@host>
  elsif ($data =~ /^[^<]+</o)
    {
      $data = $&;
      chop $data;
    }
  # From: <foobar@host>
  elsif ($data =~ /^<.*/o)
    {
      $data = $&;
      $data =~ s/[<>]//g;
    }
  # From: foobar@host
  else
    {
      return $data;
    }

  # Strip any leading and trailing whitespace
  $data =~ s/^[ \t]+//;
  $data =~ s/[ \t]+$//;

  return &parse_rfc1522 ($data);
}

# Parse names of the form =?ISO-8859-1?Q?Fran=E7ois?= Pinard
#                      or =?ISO-8859-1?Q?Fran=E7ois_Pinard?=
#                      or =?ISO-8859-1?B?4672616EE76F69732050696E617264?=
# See RFC1522 for more details.
sub parse_rfc1522
{
  local ($data) = @_;

  if ($data =~ /=\?iso-8859-1\?[^?]*\?[^?]*\?=/io)
    {
      local ($str) = $data;
      local ($encoding);

      $str =~ s/^=\?iso-8859-1\?//io;

      $encoding = $str;
      $encoding =~ s/\?.*//io;

      if ($encoding =~ /^[Qq]$/o
          || $encoding =~ /^quoted-printable$/io)
        {
          # Encoding type is Quoted-Printable

          local ($newstr) = "";
          local ($i) = $[;

          # Strip away encoding and trailing `?=', leaving the quoted name.
          $str =~ s/^[^?]*\?//;
          $str =~ s/\?=//;

          # Convert all occurences of `_' to ` '.
          $str =~ s/_/ /og;

          # Convert "=XX" (where XX is the hexidecimal representation of an
          # ascii character) to ascii.
          while ($i >= $[)
            {
              local ($s);

              $i = index ($str, "=");
              if ($i < $[)
                {
                  next;
                }

              $s = sprintf ("%c", hex (substr ($str, $i + 1, 2)));
              $newstr = $newstr . substr ($str, 0, $i) . $s;
              $str = substr ($str, $i + 3);
            }
          $data = $newstr . $str;
        }
      elsif ($encoding =~ /^[Bb]/o
             || $encoding =~ /^base64$/io)
        {
          # Encoding type is BASE64

          local ($newstr) = "";
          local ($len) = 0;
          local ($pos) = 0;

          # Strip away encoding and trailing `?=', leaving the base64 string
          $str =~ s/^[^?]*\?//;
          $str =~ s/\?=//;

          $len = length ($str);

          # There should be an even number of chars in the base64 string.
          # If not, immediately return since we cannot reliably parse it.
          if (($len % 2) != 0)
            {
              return $data;
            }

          while ($pos < $len)
            {
              local ($x) = sprintf ("%c", hex (substr ($str, $pos, 2)));
              $newstr = $newstr . $x;

              $pos += 2;
            }

          $data = $newstr;
        }
    }

  return $data;
}

# Prettify date
sub hack_Date_data
{
  local ($data) = @_;
  local (@fields, $time, $maxfield, $n);

  $data =~ s/^[ \t]+//;

  # Hack ISO-8601 date format: YYYY-MM-DD HH:MM:SS-hh:mm
  # (where hh:mm is the timezone offset from UTC)
  # This parsing doesn't attempt to convert the originating time zone to
  # the local time.
  if ($data =~ /[0-9]+-[0-9]+-[0-9]+[ \t][0-9]+:[0-9]+:[0-9]+[ \t+-][0-9:]*/o)
    {
      @fields = split (/[:\t -]+/o, $data);
      return sprintf ("%s %-2.2d %-2.2d:%-2.2d",
                      $month_conv[$fields[1]-1], $fields[2],
                      $fields[3], $fields[4]);
    }

  # Handle dates of the form:
  #    Mon, 14 Feb 1972 17:29:00 -0500
  #    14 Feb 1972 17:29:00 -0500 (EST)
  if ($data =~ /[0-9]+ ... [0-9]+ [0-9]+:[0-9]+:[0-9]/o)
    {
      @fields = split (/[:\t ]+/o, $data);
      shift @fields if ($data =~ /...,/o);

      return sprintf ("%s %-2.2d %-2.2d:%-2.2d",
                      $fields[1], $fields[0], $fields[3], $fields[4]);
    }

  return $data;
}

sub print_headers
{
  local ($data) = @_;
  local ($format, $header, $str, $num);
  local ($i) = 0;

  $data = \%current_headers
    if (! defined ($data));

  while (1)
    {
      if (! (defined ($format_vector[$i])))
        {
          # Truncate output string if appropriate.
          if ($columns > 0 && length ($str) > $columns)
            {
              # Specifying a limit field here (length($str)) prevents the
              # split function from throwing away null fields, which could
              # happen if there are sequential newlines.
              # We certainly cannot have more than length($str) fields.
              local (@lines) = split (/\n/, $str, length ($str));
              local ($len) = $#lines;
              local ($i) = 0;

              while ($i <= $len)
                {
                  if (length ($lines[$i]) > $columns)
                    {
                      $lines[$i] = substr ($lines[$i], 0, $columns);
                    }
                  $i++;
                }

              $str = join ("\n", @lines);
            }
          print "$str";
          return;
        }

      $header = $vector_header_name[$i];
      $format = $format_vector[$i];
      if ($format =~ /\\/o)
        {
          eval "\$format = \"$format\"";
        }

      $str = $str . sprintf ($format, ${$data}{$header});
      $i++;
    }
}

sub message_header_pattern_matched_p
{
  return $t
    if ($from_match_header eq '');

  return $t
    if (defined ($current_headers{$from_match_header})
        && ($current_headers{$from_match_header} =~ /$from_match_regexp/oi));

  return $nil;
}

sub err
{
  printf (STDERR join(": ", $from_progname, @_) . "\n");
}

sub getenv
{
  return "$ENV{$_[0]}"
    if (defined ($ENV{$_[0]}));
  return undef;
}

sub truep
{
  return $t
    if (&getenv ($_[0]) eq 't');
  return $nil;
}

sub my_ctime
{
  local (@weekday, @month, $time, $TZ);
  local ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);

  @weekday = ("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
  @month = ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");

  $time = ($#_ > -1)? $_[0] : time() ;
  #$TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'UTC' ) : '';
  ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
      ($TZ eq 'UTC') ? gmtime($time) : localtime($time);
  if ($TZ =~ /^([^:\d+\-,]{3,})([+-]?\d{1,2}(:\d{1,2}){0,2})([^\d+\-,]{3,})?/o)
    {
      $TZ = $isdst ? $4 : $1;
    }

  $TZ .= ' ' if ($TZ ne '');
  $year += ($year < 70) ? 2000 : 1900;
  return sprintf ("%s %s %02d %02d:%02d:%02d %s%4d",
                  $weekday[$wday], $month[$mon], $mday, $hour, $min, $sec,
                  $TZ, $year);
}


sub pop3_login
{
  local ($login, $pass) = @_;

  # greeting
  if (&pop3_response_ok_p
      && &pop3_send_command_ok_p ("USER $login")
      && &pop3_send_command_ok_p ("PASS $pass"))
    {
      return 1;
    }

  &pop3_close;
  return 0;
}

sub pop3_message_count
{
  local (@results);

  &pop3_send_command ("STAT");
  @results = &pop3_parse_response;
  return $results[1];
}

sub pop3_retrieve_lines
{
  local ($msgnumber, $bodylines) = @_;
  local ($i, $headers_end) = 0;
  local (@lines);

  $bodylines += 0;  # force into numeric context
  if ($bodylines < 0)
    {
      &pop3_send_command ("RETR $msgnumber");
    }
  else
    {
      &pop3_send_command ("TOP $msgnumber $bodylines");
    }
  if (! &pop3_response_ok_p)
    {
      &pop3_close;
      return 0;
    }

  while (<S>)
    {
      s/[\r\n]+$//;

      # The end of the transmission always ends with a single period on a
      # line by itself.
      if ($_ eq '.')
        {
          return ($headers_end, \@lines);
        }
      # Otherwise, any period at the beginning of a line is quoted with an
      # additional period.  Periods after the first aren't quoted, so at
      # the most we need strip only one.
      s/^\.//;

      # The first blank line signals the end of headers.
      if ($_ eq '' && $headers_end == 0)
        {
          $headers_end = $i;
        }

      $lines[$i] = $_;
      $i++;
    }

  return ($headers_end, \@lines);
}

sub pop3_send_command
{
  printf (S "%s\r\n", $_[0]);
}

sub pop3_response_ok_p
{
  local ($response) = &pop3_read_response;

  return (1) if ($response =~ /^\+OK/oi);
  return (0);
}

sub pop3_send_command_ok_p
{
  &pop3_send_command (@_);
  &pop3_response_ok_p;
}

sub pop3_parse_response
{
  local ($response) = &pop3_read_response;

  # In the future this may be the wrong thing, but for now we have no
  # additional exception processing interest.
  if ($response !~ /^\+OK/oi)
    {
      &pop3_close;
      return;
    }
  $response =~ s/[\r\n]+$//o;
  split (/[ \t]+/, $response);
}

sub pop3_read_response
{
  local ($line);

  while ($line = <S>)
    {
      # $line =~ s/[\r\n]+$//o;
      return $line;
    }
}

sub pop3_close
{
  # Should we send a quit in general, or just close the connection?
  # RFC1725 section 6 says doing the latter avoids entering the UPDATE
  # state, which should avoid changing any read/unread status headers.
  &pop3_send_command ("QUIT");
  shutdown (S, 2);  # 2 == SHUTDOWN_BOTH
}


# Args: host, port
sub tcpconnect
{
  local ($rhostname, $port) = @_;
  local ($proto, $name, $aliases, $type, $len, $thisaddr);
  local (@rhostaddr, $rhostaddrlen);
  local ($in, $out);

  $hostname = `hostname`;
  chop $hostname;

  ($name, $aliases, $proto) = getprotobyname ("tcp");

  if ($port !~ /^\d+$/o)
    {
      ($name, $aliases, $port) = getservbyname ($port, "tcp");
    }

  ($name, $aliases, $type, $len, $thisaddr) = gethostbyname ($hostname);

  if ($rhostname =~ /^[0-9.][0-9.]*$/o)
    {
      $canon_rhostname = &my_gethostbyaddr ($rhostname, $type);
      @rhostaddr = &ip_canonical ($rhostname);
    }
  else
    {
      ($name, $aliases, $type, $len, @rhostaddr) = gethostbyname ($rhostname);
      if ($name eq "")
        {
          print STDERR "$progname: $rhostname: cannot resolve host name.\n";
          return 0;
        }
      $canon_rhostname = $name;
    }

  # Do not use Socket::sockaddr_in even if available, since it does not
  # work for sparc-sun-solaris2.4.  In particular, the pack structure it
  # uses is "S n C4 x8", which is wrong.
  $sockaddr = "S n a4 x8";
  $thishost = pack ($sockaddr, &AF_INET, 0, $thisaddr);

  $rhostaddrlen = $#rhostaddr + 1;
  $ok = 0;
  while ($ok == 0 && $#rhostaddr > -1)
    {
      $rhost = pack ($sockaddr, &AF_INET, $port, $rhostaddr[0]);
      close (S);

      if (! socket (S, &AF_INET, &SOCK_STREAM, $proto))
        {
          print STDERR "$progname: socket: $!";
          return 0;
        }

      if (! connect (S, $rhost))
        {
          shift (@rhostaddr);
          if ($#rhostaddr >= 0)
            {
              next;
            }
          else
            {
              return 0;
            }
        }
      else
        {
          $ok = 1;
        }
    }

  &disable_stdio_buffering (S);
  return 1;
}

sub initialize_sockvars
{
  # Args to shutdown.
  $SHUTDOWN_RECEIVE = 0;
  $SHUTDOWN_SEND    = 1;
  $SHUTDOWN_BOTH    = 2;

  if ( int ($]) <= 4 )
    {
      # Push some include dirs which are pretty standard, just in case.
      # Perl5 does not usually install .ph files.
      push (@INC, "$ENV{HOME}/lib/perl",
                  "/usr/local/gnu/lib/perl",
                  "/usr/local/lib/perl",
                  "/usr/lib/perl"
           );

      if (! &require_soft ("sys/socket.ph"))
        {
          # Backdown if socket.ph cannot be found.
          # These are probably correct, but not guaranteed to be.
          # For example, on sparc-sun-solaris2.4, SOCK_STREAM is 2, not 1.
          sub AF_INET     { return 2; }
          sub SOCK_STREAM { return 1; }
        }
    }
  else
    {
      eval "use Socket;";
    }
}

sub my_gethostbyaddr
{
  local ($addrstring, $type) = @_;
  local ($addr) = 0;
  local ($name) = "";

  $addr = &ip_canonical ($addrstring);
  $addrstring = sprintf ("%d.%d.%d.%d", unpack ("C4", $addr));
  $name = gethostbyaddr($addr, $type);

  return $addrstring
    if ($name eq "");
  return $name;
}

sub ip_canonical
{
  local ($addrstring) = @_;
  local ($addr) = $addrstring;

  if ($addrstring =~ /^[0-9.][0-9.]*$/o)
    {
      if ($addrstring =~ /[.]/o)
        {
          # String is in 255.255.255.255 format
          local (@octet) = split (/[.]/o, $rhostname);
          $addr = pack ('C4', @octet);
        }
      else
        {
          # If string is not in octet form but instead is a flat ascii IP,
          # then just convert it to network byte order.
          # Convert addrstring to the dotted decimal representation for it.
          #
          # source IP addresses are specified in this flat format in the
          # IRC DCC protocol; I don't know if it's common anywhere else.
          $addrstring = pack ("I", "$addrstring");
          $addr = &htonl ($addrstring);
        }
    }
  return $addr;
}

sub this_host_big_endian_p
{
  local ($x) = 1;
  local (@y) = unpack ("c2", pack ("i", $x));

  if ($y[0] == 1)
    {
      # we're little-endian
      return 0;
    }
  # we're big-endian
  return 1;
}

# Convert integers from host byte order to network byte order.
# Network byte order is big-endian.
sub htonl
{
  local ($h) = @_;
  local (@o);

  if (&this_host_big_endian_p ())
    {
      return $h;
    }

  @o = unpack ('C4', $h);
  $h = pack ('C4', $o[3], $o[2], $o[1], $o[0]);
  return $h;
}

sub disable_stdio_buffering
{
  foreach $handle (@_)
    {
      local ($orig_handle) = select ($handle);
      $| = 1;
      select ($orig_handle);
    }
}

sub require_soft
{
  local ($f) = @_;

  foreach $dir (@INC)
    {
      if (-f "$dir/$f")
        {
          require "$f";
          return "$dir";
        }
    }
  return 0;
}

__EOF__

# local variables:
# mode: perl
# eval: (auto-fill-mode 1)
# end:

# from ends here
