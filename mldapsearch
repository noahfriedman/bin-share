#!/usr/bin/env perl
# mldapsearch --- my ldapsearch implementation

# Author: Noah Friedman <friedman@splode.com>
# Created: 2012-09-28
# Public domain.

# $Id: mldapsearch,v 1.4 2015/12/09 21:09:36 friedman Exp $

use strict;
use warnings qw(all);

use Net::LDAP;
use Net::LDAP::LDIF;
use Getopt::Long;

our %opt = ( host    => 'ldap',
             scope   => 'sub',
             onerror => 'die',
             verify  => 'none',
             exclude => [],
           );

sub parse_options
{
  local *ARGV = \@{$_[0]}; # modify our local arglist, not real ARGV.

  # Precedence for defs (highest->lowest): options, rc file, default
  my $rc = $ENV{MLDAPSEARCHRC} || "$ENV{HOME}/.mldapsearchrc";
  do $rc if -f $rc;

  my $parser = Getopt::Long::Parser->new;
  $parser->configure (qw(bundling autoabbrev));
  my $succ = $parser->getoptions
    ( "debug:i"                => \$opt{debug},
      "b|root|base=s"          => \$opt{base},
      "h|host=s",              => \$opt{host},
      "D|bind=s",              => \$opt{bind},
      "w|pswd|pass=s",         => \$opt{password},
      "p|port=s",              => \$opt{port},
      "s|scope=s",             => \$opt{scope},
      "P|cert=s"               => \$opt{cafile},

      "E|exclude-attribute=s@" => \$opt{exclude},
      "wrap=i"                 => \$opt{wrap},
      "lowercase|lcase"        => \$opt{lcase},
      "sort"                   => \$opt{sort},
    );

  $opt{debug} = 1 if defined $opt{debug} && $opt{debug} == 0;
  if ($opt{debug})
    {
      my $n = 0;
      map { $n = ($n << 1) | $_ } split //, $opt{debug};
      $opt{debug} = $n;
    }

  $opt{exclude} = [map { split (/(?:\s*,\s*)|\s+/, $_) } @{$opt{exclude}}];
}

# Query server to find out what directory roots are available, and if more
# than one, use hostname's fqdn to guess most likely relevant one.
sub baseDN
{
  my @nc = $_[0]->root_dse->get_value ("namingContexts");
  map { return $_ unless lc $_ eq "o=netscaperoot" } @nc if @nc <= 2;

  use POSIX qw(uname);
  my $nodename = (uname())[1];
  unless ($nodename =~ /\./) { # try to get FQDN
    my @n = gethostbyname ($nodename);
    if (@n) {
      for my $h ($n[0], split (/\s+/, $n[1])) {
        if ($h =~ /\./) {
          $nodename = $h;
          last;
        }
      }
    }
  }
  my @dc = split (/\./, lc $nodename);
  # Create "normalized" table by forcing lcase and stripping whitespace
  my %nc = map { my $key = lc $_;
                 $key =~ s/\s+//g;
                 $key => $_ ;
               } @nc;
  # Search for "dc=foo,dc=com" and "o=foo.com"
  map { map { return $nc{$_} if exists $nc{$_}
            } (join (",", map { "dc=$_" } @dc),
               "o=" . join (".", @dc));
        shift @dc;
      } @dc;

  return $nc[0]; # if all else fails, return first advertised.
}

sub LDIF
{
  my $data = shift;

  open (my $fh, '>', \my $buffer);
  my $ldif = Net::LDAP::LDIF->new ($fh, 'w', @_);
  $ldif->write_entry ($data);
  return $buffer;
}

sub main
{
  parse_options (\@_);
  my $ldap = Net::LDAP->new ($opt{host}, %opt) || die "$@\n";
  $ldap->bind ($opt{bind}, %opt) if defined $opt{bind};

  $_[0] = sprintf ("uid=%s", $_[0]) unless $_[0] =~ /=/;
  my (@srch, @attr);
  map { my $array = /=/ ? \@srch : \@attr;
        push @$array, $_
      } @_;

  my $filter = sprintf ("(|%s)", join ("", map { /^\(/ ? $_ : "($_)" } @srch));
  $opt{filter} = $filter;

  $opt{attrs} = \@attr if @attr;
  $opt{base} = baseDN ($ldap) unless defined $opt{base};

  my @excl   = map { $_ => undef } @{$opt{exclude}};
  my @lopt   = (change    => undef     );
  push @lopt,  (sort      => 1         ) if $opt{sort};
  push @lopt,  (wrap      => $opt{wrap}) if $opt{wrap};
  push @lopt,  (lowercase => 1         ) if $opt{lcase};

  my $result = $ldap->search (%opt);
  while ($_ = $result->shift_entry)
    {
      $_->delete (@excl) if @excl;
      print LDIF ($_, @lopt);
    }
}

main (@ARGV);

1;
