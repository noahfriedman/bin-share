#!/bin/sh
# rotate-log --- rotate accounting logs, optionally compressing old logs
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1992-02-10
# Last modified: 1994-03-13
# Public domain

# Commentary:
# Code:

# Name by which this script was invoked. 
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

usage="Usage: $progname {options} [logfile-name ...]

Options are:
-c, --compress                Compress logs while rotating.
-C, --compress-method METHOD  Method to use for compressing; one of
                              ${bq}compact$eq, ${bq}compress$eq, ${bq}gzip$eq.
                              Default is ${bq}compress$eq.
-D, --debug                   Turn on shell debugging ($bq${bq}set -x$eq$eq).
-d, --default-directory  DIR  Default directory for log files listed without
                              pathname (i.e. no "/" chars in name)
-g, --chgrp            GROUP  Change group ownership to GROUP on rotated logs.
-h, --help                    You're looking at it.
-m, --chmod             MODE  Change permissions to MODE on rotated logs.
-n, --number-of-logs       N  Keep up to N old versions of log (default 7).
                              Rotated logs are numbered zero-origin.
-o, --chown            OWNER  Change owner of logs to OWNER (you should use
                              OWNER.GROUP and avoid using --chgrp if the
                              ${bq}chown${eq} command supports this syntax).
-v, --verbose                 Chatter away while working.
"

# Usage: value=`(set - "$1" "$2"; eval "$get_option_argument")`
#
# Long option syntax is `--foo=bar' or `--foo bar'.  2nd argument ARG
# won't get used if first long option syntax was used. 
# If 3rd argument OPTIONAL is set, then 2nd may be empty without resulting
# in an error (i.e. option argument is optional)
#
# Returns number of positions caller should shift.
# If retval = 3, caller should exit.
get_option_argument='
  {
    option="$1" arg="$2" arg_optional="$3" shift_num=2
    case "$option" in
      --*=* )
        arg=`echo $option | sed -e "s/^[^=]*=//"` 
        shift_num=1
       ;;
    esac
    case "$arg" in
      "" )
        case "$arg_optional" in
          "" )
            case "$option" in 
              --*=* ) option=`echo $option | sed -e "s/=.*//"` ;;
            esac
            echo "$progname: option $bq$option$eq requires argument." 1>&2
            echo "$usage" 1>&2
            exit 3
           ;;
        esac
        exit 1
       ;;  
    esac
    echo "$arg"
    exit $shift_num
  }'

# Some bourne shells don't allow a numeric argument to `shift'.
# Usage: eval "shift_num=n; $shift_n_times"
shift_n_times='
  {
    while : ; do
      case "$shift_num" in 0 | "" ) break ;; esac
      shift_num=`expr $shift_num - 1`
      shift
    done
  }'

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
chgrp_args=
chmod_args=
chown_args=
compressp=
compress_method=compress
debug=
default_directory=.
number_of_logs=7
verbose=

# Parse command line arguments. 
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character. 
while test $# != 0; do
  case "$1" in 
    -c | --compress )
      compress=t
      shift
     ;;
    -C | --compress-method* | --compress-* )
      compress_method=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -D | --debug | --deb* )
      debug=t
      shift
     ;;
    -d | --default-directory* | --def* )
      default_directory=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -g | --chgrp* | --chg* )
      chgrp_args=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -m | --chmod* | --chm* )
      chmod_args=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -n | --number-of-logs* | --n* )
      number_of_logs=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -o | --chown* | --cho* )
      chown_args=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -v | --verbose | --v* )
      verbose=t
      shift
     ;;
    -h | --help | --h )
      echo "$usage" 1>&2
      exit 1
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    --*=* )
      arg=`echo $1 | sed -e 's/=.*//'`
      echo "$progname: unknown option $bq$arg$eq" 1>&2
      echo "$usage" 1>&2
      exit 1
     ;;
    -* )
      echo "$progname: unknown option $bq$1$eq" 1>&2
      echo "$usage" 1>&2
      exit 1
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in t ) set -x ;; esac

case $# in
  0 )
    echo "$progname: at least one log name is required as an argument." 1>&2
    echo "$usage" 1>&2
   ;;
esac

orig_cwd=${PWD-`pwd`}
max_log_number=`expr $number_of_logs - 1`  # make it zero-origin

case "$compress_method" in
  compact )  compress_cmd='compact -f';  suffix='.C'  ;;
  compress ) compress_cmd='compress -f'; suffix='.Z'  ;;
  gzip )     compress_cmd='gzip';        suffix='.gz' ;;
  * )
    echo "*** $progname: unknown compress-method $bq$compress_method$eq" 1>&2
    exit 1
   ;;
esac   

for log in ${1+"$@"} ; do
  cd "$orig_cwd"

  dirname=`echo "$log" \
           | sed -e 's/\/*$//
                     s/\/[^\/]*$//'`
  basename=`echo "$log" \
            | sed -e 's/\/*$//
                      s/.*\///'`
  case "$dirname" in "$basename" )
    dirname=$default_directory ;;
  esac

  if cd "$dirname" ; then
    :
  else
    echo "*** $progname: skipping $bq$log$eq logs." 1>&2
    continue
  fi

  if test ".$compressp" = '.t' ; then
    case "$verbose" in t )
      echo "Compressing uncompressed logs in $dirname..." ;;
    esac

    num=$max_log_number
    while : ; do
      case $num in -1 ) break ;; esac
      file="$basename.$num"

      test -f "$file" \
       && $compress_cmd "$file" \
       && test ".$verbose" = '.t' \
       && echo "$file -> $file$suffix"

      num=`expr $num - 1`
    done

    # Don't do this.  Things like accounting, syslogd, and so on might
    # still have the file open, and all they'd do is corrupt the compressed
    # file.  It'll get compressed the next time log rotation happens, and
    # by then it probably won't be open anymore.
    #$compress_cmd "$basename" \
    # && test ".$verbose" = '.t' \
    # && echo "$basename -> $basename$suffix"

    case "$verbose" in t )
      echo "Finished compressing $bq$log$eq logs." ;;
    esac
  else
    suffix=
  fi

  case "$verbose" in t )
    echo "Rotating logs in directory $dirname..." ;;
  esac

  num=$max_log_number
  nextnum=$number_of_logs
  while : ; do
    case $num in
      -2 ) break ;;
      -1 )
        # move `log' to `log.0'
        # Note that logfile will not be compressed even if --compress was
        # specified, so don't append $suffix.  See comments in relevent
        # code above.
        oldfile="$basename"
        newfile="$basename.0"
       ;;
      * )
        oldfile="$basename.$num$suffix"
        newfile="$basename.$nextnum$suffix"
       ;;
    esac

    test -f "$oldfile" \
     && test $nextnum -lt $max_log_number \
     && mv "$oldfile" "$newfile" \
     && {
          case "$verbose" in t )
            echo "$oldfile -> $newfile" ;;
          esac

          test ".$chmod_args" = . || chmod $chmod_args "$newfile"
          test ".$chgrp_args" = . || chgrp $chgrp_args "$newfile"
          test ".$chown_args" = . || chown $chown_args "$newfile"
        }

    nextnum=$num
    num=`expr $num - 1`
  done

  # Create new logfile
  : > "$basename"
  test ".$chmod_args" = . || chmod $chmod_args "$logfile"
  test ".$chgrp_args" = . || chgrp $chgrp_args "$logfile"
  test ".$chown_args" = . || chown $chown_args "$logfile"

  case "$verbose" in t )
    echo "Created $basename"
    echo "Finished rotating $bq$log$eq logs."
   ;;
  esac
done

# rotate-log ends here
