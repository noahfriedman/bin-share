#! /bin/sh
# symlink-resolve --- dereference symbolic links

# Copyright (C) 1993, 1995, 1998 Noah S. Friedman

# Author: Noah Friedman <friedman@splode.com>
# Created: 1993-02-07

# $Id: symlink-resolve,v 1.8 1996/08/09 05:16:42 friedman Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.

# Commentary:

# Resolve pathnames until there are no more symbolic links.  Resulting
# pathname be not be a file that actually exists (depending on whether
# symlinks point to nonexistent files).

# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

usage="Usage: $progname {options} [path1] {path2} {...}

Options are:
-D, --debug                  Enable shell/perl debugging.
-h, --help                   You're looking at it.
-n, --no-canonicalize        Do not canonicalize pathnames by resolving
                             references to $bq..$eq, etc.
"

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
debug=
SYMLINK_CANONICALIZE=

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while : ; do
  case $# in 0) break ;; esac
  case "$1" in
    -D | --debug | --d* )
      # This option is passed to perl for interactive debugging
      debug=-d
      shift
     ;;
    -h | --help | --h )
      echo "$usage" 1>&2
      exit 0
     ;;
    -n | --no-canonicalize | --n* )
      SYMLINK_CANONICALIZE=nil
      export SYMLINK_CANONICALIZE
      shift
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -? | --* )
      case "$1" in
        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
        * )     arg="$1" ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    -??* )
      # Split grouped single options into separate args and try again
      optarg="$1"
      shift
      set fnord `echo "x$optarg" | sed -e 's/^x-//;s/\(.\)/-\1 /g'` ${1+"$@"}
      shift
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in -d ) set -x ;; esac

case $# in
  0 )
   echo "$usage" 1>&2
   exit 1
  ;;
esac

exec perl $debug - ${1+"$@"} <<'__EOF__'

if ($ENV{'SYMLINK_CANONICALIZE'} ne 'nil')
  {
   chop ($pwd = `pwd`);
  }

next_path:
for ($i = 0; $i < @ARGV; $i++)
  {
   @p = split (/\//, "$ARGV[$i]");
   $link_count = 0;
   for ($j = 0; $j < @p; $j++)
     {
      $orig_component = $k = join ("/", @p[0 .. $j]);
      while ($l = readlink($k))
        {
         $k = $l;
         # Simple way of detecting symlink loops (it unfortunately causes
         # the system to give up when there are simply too many levels,
         # even if resolution would eventually occur).  This parameter is
         # adjustable, of course.  Most unix kernels allow a depth of 8.
         if ($link_count++ == 32)
           {
            print STDERR "symlink-resolve: $ARGV[$i]: " .
                         "Too many levels of symbolic links\n";
            next next_path;
           }
        }
      if ($k eq $orig_component)
        {
         next;
        }
      if (substr ($k, 0, 1) eq "/")
        {
         # Absolute link.  Trash $p[0]-$p[$j+1] and replace with readlinked
         # path components.  Set $j to -1 so that next iteration of loop
         # will check array @p from start.
         splice (@p, 0, $j + 1, split (/\//, $k));
         $j = -1;
        }
      else
        {
         # Insert partial (relative) path component into array in place of
         # current element $p[$j]
         splice (@p, $j, 1, split (/\//, $k));
         $j--;
        }
     }
   $_ = join ("/", @p);

   # If pathname should not be canonicalized, exit here.
   if ($ENV{'SYMLINK_CANONICALIZE'} eq 'nil')
     {
      print "$_\n";
      exit (0);
     }

   # Canonicalize pathname.
   s/^\.$/$pwd/o;                     # Replace single "." with pwd.
   s/^([^\/])/$pwd\/\1/o;             # Prepend pwd if relative.
   s/\/\.\//\//og;                    # Remove any occurence of "/./".
   s/^.*\/\//\//og;                   # Get rid of "//" occurences.
   # Must do this in a loop to handle overlapping `/' character in
   # instances of "/../../"
   while (/\/[^\/][^\/]*\/\.\.\//o)
     {
      s/\/[^\/][^\/]*\/\.\.\//\//o;   # Resolve most references to ".."
     }
   s/\/[^\/][^\/]*\/\.\.$//o;         # Resolving trailing ".."
   s/^\/\.\.\//\//go;                 # Eliminate leading "/.."
   if ($#ARGV > 0)
     {
       print "$ARGV[$i] -> ";
     }
   print "$_\n";
  }

__EOF__

# symlink_resolve ends here
