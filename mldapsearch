#!/usr/bin/env perl
# mldapsearch --- my ldapsearch implementation

# Author: Noah Friedman <friedman@splode.com>
# Created: 2012-09-28
# Public domain.

# $Id: mldapsearch,v 1.9 2017/07/21 23:19:49 friedman Exp $

use strict;
use warnings qw(all);

use FindBin;
use lib "$FindBin::Bin/../../lib/perl";
use lib "$ENV{HOME}/lib/perl";

use NF::PrintObject qw(:all);
$object_pp_verbose = 2; # multi-line
$object_pp_maxlen  = 0; # unlimited

use Net::LDAP;
use Net::LDAP::LDIF;
use Getopt::Long;

our %opt = ( host      => 'ldap',
             scope     => 'sub',  # base, one|single, sub|subtree, children
             onerror   => undef,  # undef, die, warn
             verify    => 'none',
             exclude   => [],
             oc_attrs  => [],     # only attrs from these object classes
             metaquery => '',
             deref     => 'never',  # never, search, find, always
             andor     => '&',
           );

our @default_search_attrs = (qw(uid cn));

our %andor_map = ( '&'   => '&',   '|'  => '|',
                   'a'   => '&',   'o'  => '|',
                   'and' => '&',   'or' => '|',
                 );

sub parse_options
{
  local *ARGV = \@{$_[0]}; # modify our local arglist, not real ARGV.

  # Precedence for defs (highest->lowest): options, rc file, default
  my $rc = $ENV{MLDAPSEARCHRC} || "$ENV{HOME}/.mldapsearchrc";
  do $rc if -f $rc;

  my $parser = Getopt::Long::Parser->new;
  $parser->configure (qw(bundling autoabbrev no_getopt_compat));
  my $succ = $parser->getoptions
    ( "debug:i"                => \$opt{debug},
      "dump-result"            => sub { $opt{dump}++ },

      "a|deref-aliases=s"      => \$opt{deref},
      "b|root|base=s"          => \$opt{base},
      "h|host=s",              => \$opt{host},
      "D|bind=s",              => \$opt{bind},
      "w|pswd|pass=s",         => \$opt{password},
      "p|port=s",              => \$opt{port},
      "s|scope=s",             => \$opt{scope},
      "P|cert=s"               => \$opt{cafile},

      "n|sizelimit=i"          => \$opt{sizelimit},
      "E|exclude-attribute=s@" => \$opt{exclude},
      "O|oc|objectclass=s@"    => \$opt{oc_attrs},
      "wrap=i"                 => \$opt{wrap},
      "lowercase|lcase"        => \$opt{lcase},
      "sort"                   => \$opt{sort},
      "types-only"             => \$opt{typesonly},
      "andor=s"                => \$opt{cmd_andor},

      "root-dse" => sub { $opt{metaquery} = 'rootdse' },
      "schema"   => sub { $opt{metaquery} = 'schema' },
    );

  $opt{debug} = 1 if defined $opt{debug} && $opt{debug} == 0;
  if ($opt{debug})
    {
      #$^W = 1;
      my $n = 0;
      map { $n = ($n << 1) | $_ } split //, $opt{debug};
      $opt{debug} = $n;
    }

  if ($opt{cmd_andor})
    {
      my $key = lc $opt{cmd_andor};
      $opt{andor} = $andor_map{$key} if exists $andor_map{$key};
    }

  map { $opt{$_} = [map { split (/(?:\s*,\s*)|\s+/, $_) } @{$opt{$_}}]
      } (qw(exclude oc_attrs));
}

# Query server to find out what directory roots are available, and if more
# than one, use hostname's fqdn to guess most likely relevant one.
sub baseDN
{
  my $ldap = shift;
  my $root_dse = get_root_dse ($ldap);

  # Try these first.  Active Directory specific?
  map { my @nc = $root_dse->get_value ($_);
        return $nc[0] if @nc;
      } (qw(defaultNamingContext rootDomainNamingContext));

  my @nc = $root_dse->get_value ("namingContexts");
  map { return $_ unless lc $_ eq "o=netscaperoot" } @nc if @nc <= 2;

  use POSIX qw(uname);
  my $nodename = (uname())[1];
  unless ($nodename =~ /\./) { # try to get FQDN
    my @n = gethostbyname ($nodename);
    if (@n) {
      for my $h ($n[0], split (/\s+/, $n[1])) {
        if ($h =~ /\./) {
          $nodename = $h;
          last;
        }
      }
    }
  }
  my @dc = split (/\./, lc $nodename);
  # Create "normalized" table by forcing lcase and stripping whitespace
  my %nc = map { my $key = lc $_;
                 $key =~ s/\s+//g;
                 $key => $_ ;
               } @nc;
  # Search for "dc=foo,dc=com" and "o=foo.com"
  map { map { return $nc{$_} if exists $nc{$_}
            } (join (",", map { "dc=$_" } @dc),
               "o=" . join (".", @dc));
        shift @dc;
      } @dc;

  return $nc[0]; # if all else fails, return first advertised.
}

sub LDIF
{
  my $data = shift;

  open (my $fh, '>', \my $buffer);
  my $ldif = Net::LDAP::LDIF->new ($fh, 'w', @_);
  $ldif->write_entry ($data);
  return $buffer;
}

sub get_root_dse
{
  my $ldap = shift;

  return $ldap->{m_rootdse} if defined $ldap->{m_rootdse};

  # Load root dse, including operational attributes.
  # Some servers support a '+' glob to return OAs, but others (like redhat
  # directory server) require them to be enumerated explicitly.
  @_ = (qw(* +
           altServer
           namingContexts
           subschemaSubentry
           supportedControl
           supportedExtension
           supportedFeatures
           supportedLDAPVersion
           supportedSASLMechanisms
           vendorName
           vendorVersion))
    unless @_;

  $ldap->{m_rootdse} = $ldap->root_dse (attrs => \@_);
}

sub do_search
{
  my ($ldap, $opt_override) = (shift, {});
  $opt_override = shift if @_ && ref ($_[0]) eq 'HASH';
  my %parm = (%opt, %$opt_override);

  @_ = (qw( (objectClass=*) * + )) unless @_;
  if (@_ && $_[0] !~ /=/)
    {
      my $val = shift;
      unshift @_, map { sprintf ("%s=%s", $_, $val) } @default_search_attrs;
    }
  my (@srch, @attr);
  map { my $array = /[<=>~]/ ? \@srch : \@attr;
        push @$array, $_
      } @_;

  # Some non-compliant servers really dislike '(|(foo=bar))' if there is
  # only one subexpression.
  my @exprs = map { /^\(/ ? $_ : "($_)" } @srch;
  $parm{filter} = @exprs > 1 ? sprintf ("(%s%s)", $parm{andor}, join ("", @exprs)) : $exprs[0] ;

  $parm{attrs} = \@attr if @attr;
  $parm{base} = baseDN ($ldap) unless defined $parm{base};

  # An example of how one might use a control
  #use Net::LDAP::Control::ManageDsaIT;
  #my $manage = Net::LDAP::Control::ManageDsaIT->new ( critical => 0 );
  #push @{$parm{control}}, $manage;

  my $result = $ldap->search (%parm);
  if ($result->is_error)
    {
      printf(STDERR "Error: %s\n%s\n",
             $result->error_name,
             $result->error_text);
      return;
    }

  return $result;
}

sub do_print
{
  my $result = shift;

  my @lopt   = (change    => undef     );
  push @lopt,  (sort      => 1         )  if $opt{sort};
  push @lopt,  (wrap      => $opt{wrap})  if $opt{wrap};
  push @lopt,  (lowercase => 1         )  if $opt{lcase};

  map { my $entry = $_;
        map { $entry->delete ($_) } @{$opt{exclude}} if $entry->can ('delete');
        if ($opt{dump})
          {
            my $obj = ($opt{dump} > 1
                       ? $entry
                       : ($entry->{attrs}
                          ? $entry->{attrs}
                          : $entry->{asn}->{attributes}));
            print object_pp ($obj), "\n";
          }
        else
          { print LDIF ($entry, @lopt); }
      } ($result->can('entries') ? $result->entries : $result);
}

sub objectclass_attrs
{
  my $ldap = shift;

  #return unless @_;
  my $ocs = $ldap->schema->{oc};
  map { my $elt = $ocs->{lc $_};
        map { if (ref ($elt->{$_}) eq 'ARRAY')
                { @{$elt->{$_}} }
              else
                { () }
            } (qw(must may));
      } @_;
}

sub main
{
  parse_options (\@_);
  my $ldap = Net::LDAP->new ($opt{host}, %opt) || die "$@\n";
  $ldap->bind ($opt{bind}, %opt) if defined $opt{bind};

  if ($opt{metaquery} eq 'rootdse')
    {
      do_print (get_root_dse ($ldap, @_));
    }
  elsif ($opt{metaquery} eq 'schema')
    {
      print object_pp ($ldap->schema), "\n";
    }
  else
    {
      push @_, objectclass_attrs ($ldap, @{$opt{oc_attrs}});
      my $result = do_search ($ldap, @_);
      do_print ($result) if $result;
    }
}

main (@ARGV);

1;
