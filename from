#! /bin/sh
# from --- show you who your mail is from
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1992-01-19
# Public domain

# $Id: from,v 1.10 1995/10/19 22:47:06 friedman Rel friedman $

# Commentary:
# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"
bs='\'
dq='"'

# See if "\n" is interpreted by echo as a newline sequence.
x="`echo 'foo\nbar'`"
y='foo
bar'
if test "$x" = "$y"; then
  bs='\\'
fi

usage="Usage: $progname {options} {folder {...}}

Options are:
-c, --columns    COLS        Truncate lines exceeding COLS length on output.
                             If COLS=0 or output is not to a terminal, no
                             truncation is done.  The default is
                             the current width of the terminal.
-D, --debug                  Enable interactive debugging.
-e, --envelope               Show message envelope instead of headers.
                             This causes any formatting options (e.g.
                             $bq--columns$eq, $bq--numbered$eq) to be ignored.
-f, --format     FMT         Use FMT as the output format.  The option
                             $bq--help-format$eq gives instructions for this.
-h, --help                   You're looking at it.
-H, --help-format            Get documentation about the format of the FMT
                             argument to $bq--format$eq.
-n, --numbered               Show number of message with respect to the
                             current folder.  See also $bq--help-format$eq.
-p, --no-parse               Do not do fancy parsing of From and Date fields.
-u, --user       USER        Show headers of USER's spooled messages.
"

format_usage="$progname format usage: --format='%{{-}{n}{.m}}[header] ...' ...

The FMT specifier to the $bq--format$eq option can contain literal text for
the output, along with header specifiers in the form

      %{{-}{n}{.m}}Header

where

  * ${bq}n$eq is the line width reserved for the value of ${bq}Header$eq.
  * $bq-$eq means that header strings shorter than ${bq}n$eq chars are
    flushed left within the field, instead of right.
  * $bq.m$eq is the maximum allowed length of the field; if the header
    string is longer than this, it is truncated.
  * ${bq}Header$eq is the name of the header, e.g. ${bq}Subject$eq.

Some special ${dq}header names$dq are defined for useful information that
cannot generally be obtained from message headers.  As usual, you can use
general format specifiers, e.g ${dq}%-4.3{TLINES}$dq.  These special names,
surrounded by curly braces, are:

  * $bq{TLINES}$eq
    The number of this message line irrespective of any folder it
    may have come from (if more than one folder was specified on the
    command line).
  * $bq{FLINES}$eq
    The number of this message in the current folder.  This number is reset
    whenever this program begins reading a new folder specified on the
    command line.
  * $bq{FOLDER}$eq
    The name of this folder, as specified on the command line.


For example, given a message with headers of the form

      From: Noah Friedman <friedman@prep.ai.mit.edu>
      To: nobody@gnu.ai.mit.edu
      Subject: example
      Date: Tue, 18 Oct 94 12:22:50 CDT

here are some valid format specifiers and the output that results from them.
($bq-|$eq indicates the results here; it is not actually printed.)

      ${dq}%From %Subject$dq
      -| Noah Friedman  example

      ${dq}%-19.18From %-13.12Date %-.45Subject$dq
      -| Noah Friedman       Oct 18 12:22  example

      ${dq}To %-19To %-13Date %20Subject$dq
      -| To nobody@gnu.ai.mit.edu Oct 18 12:22                   example

      ${dq}To %-19.18To %-13.12Date %-.45Subject$dq
      -| To nobody@gnu.ai.mit.  Oct 18 12:22  example

      ${dq}From: %From${bs}nSubject: %Subject${bs}nDate: %Date${bs}n$dq
      -| From: Noah Friedman
      -| Subject: example
      -| Date: Oct 18 12:22
      -|

If you use something like last example format specifier, you may wish to
use the $bq--no-parse$eq option to avoid any parsing (and therefore
truncation) of the From and Date lines.
"

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
FROMRC=${FROMRC-$HOME/.fromrc}
FROM_PARSEP=t
FROM_NUMBERED=
FROM_USER=$USER
debug=
envelopep=

# if stdout is not a tty, then disable truncation (user may explicitly
# enables it later by use of the --columns option).
if test -t 1; then
  # Decrement number of columns by 1 since output in last column causes
  # wraparound on many (most?) terminals.
  COLUMNS=`expr ${COLUMNS-80} - 1`
else
  COLUMNS=0
fi

# Precedence for defs (highest->lowest): options, env, ~/.fromrc, default
if test -f "$FROMRC"; then
  . "$FROMRC"
fi

# Usage: eval "$getopt"; value=$optarg
# or     optarg_optional=t; eval "$getopt"; value=$optarg
#
# This function automatically shifts the positional args as appropriate.
# The argument to an option is optional if the variable `optarg_optional'
# is non-empty.  Otherwise, the argument is required and getopt will cause
# the program to exit on an error.  optarg_optional is reset to be empty
# after every call to getopt.  The argument (if any) is stored in the
# variable `optarg'.
#
# Long option syntax is `--foo=bar' or `--foo bar'.  2nd argument
# won't get used if first long option syntax was used.
#
# Note: because of broken bourne shells, using --foo=bar syntax can
# actually screw the quoting of args that end with trailing newlines.
# Specifically, most shells strip trailing newlines from substituted
# output, regardless of quoting.
getopt='
  {
    optarg=
    case "$1" in
      --*=* )
        optarg=`echo "$1" | sed -e "1s/^[^=]*=//"`
        shift
       ;;
      * )
        case ${2+set} in
          set )
            optarg="$2"
            shift
            shift
           ;;
          * )
            case "$optarg_optional" in
              "" )
                case "$1" in
                  --*=* ) option=`echo "$1" | sed -e "1s/=.*//;q"` ;;
                  * ) option="$1" ;;
                esac
                exec 1>&2
                echo "$progname: option $bq$option$eq requires argument."
                echo "$progname: use $bq--help$eq to list option syntax."
                exit 1
               ;;
           esac
         ;;
        esac
     ;;
    esac
    optarg_optional=
  }'

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while : ; do
  case $# in 0) break ;; esac
  case "$1" in
    -c | --columns* | --c* )
      eval "$getopt"
      COLUMNS=$optarg
     ;;
    -D | --debug | --d* )
      debug=-d
      shift
     ;;
    -e | --envelope | --e* )
      envelopep=t
      shift
     ;;
    -f | --format* | --f* )
      eval "$getopt"
      FROM_FORMAT=$optarg
     ;;
    -H | --help-format | --help-* )
      echo "$format_usage" 1>&2
      exit 1
     ;;
    -h | --help | --h* )
      echo "$usage" 1>&2
      exit 1
     ;;
    -n | --numbered | --n* )
      FROM_NUMBERED=t
      shift
     ;;
    -p | --no-parse | --n* )
      FROM_PARSEP=
      shift
     ;;
    -u | --user* | --u* )
      eval "$getopt"
      FROM_USER=$optarg
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -? | --* )
      case "$1" in
        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
        * )     arg="$1" ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    -??* )
      # Split grouped single options into separate args and try again
      optarg="$1"
      shift
      set fnord `echo "x$optarg" | sed -e 's/^x-//;s/\(.\)/-\1 /g'` ${1+"$@"}
      shift
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in -d ) set -x ;; esac

case $# in
  0 )
    if test ".$FROM_USER" != ".$USER" || test "${MAIL-unset}" = "unset"; then
      USER=${USER-${LOGNAME-`{ id | sed -ne 's/.*uid=[0-9]*(//
                                             s/).*//
                                             p'
                             } \
                             || { (whoami) 2> /dev/null; }`}}

      MAIL=
      for f in /var/mail /var/spool/mail /usr/spool/mail /usr/mail ; do
        if test -f "$f/$USER" ; then
          MAIL="$f/$USER"
          break
        fi
      done

      case "$MAIL" in
        '' ) exit 1 ;;
      esac
    fi

    set fnord "$MAIL"
    shift
   ;;
esac

case "$envelopep" in
  t )
    exec grep '^From ' ${1+"$@"}
 ;;
esac

case "${FROM_FORMAT+set}" in
  set ) : ;;
  * )
    FROM_FORMAT='%-19.18From %-13.12Date %Subject\n'

    case "$FROM_NUMBERED" in
      t )
        FROM_FORMAT="%-3{FLINES} $FROM_FORMAT"
       ;;
    esac
   ;;
esac

FROM_PROGNAME=$progname

export COLUMNS FROM_FORMAT FROM_PARSEP FROM_PROGNAME

# By using a here-document to include the source of the perl script (to
# avoid command line length limits), we usurp the normal stdin the inferior
# process might have expected.  So dup stdin onto fd 9, and before the
# inferior process is started, it will be reduped back onto fd 0.
exec ${FROM_PERL-${PERL-perl}} $debug $includes - ${1+"$@"} 9<&0 <<'__EOF__'

&main;

sub main
{
  local ($i) = 0;

  $from_progname = &getenv ('FROM_PROGNAME');

  # See comments preceding perl invocation for an explanation.
  if (! open (STDIN, "<&9"))
    {
      &err ("cannot recover stdin from fd 9", "$!");
      exit (1);
    }

  close (9);

  &initialize_variables ();
  &make_format_vector (&getenv ("FROM_FORMAT"));

  $i = 0;
  foreach $file (@ARGV)
    {
      if ($file ne "-" && ! -r $file)
        {
          # Set $! appropriately.
          open (F, "<$file");
          &err ("$file", "$!.");
          close (F);

          splice (@ARGV, $i, 1);
          $exit_status = 1;
        }
      $i++;
    }

  foreach $file (@ARGV)
    {
      &process_file ($file);
    }

  exit ($exit_status);
}

sub err
{
  printf (STDERR join(": ", $from_progname, @_) . "\n");
}

sub getenv
{
  local ($v) = @_;

  if (defined ($ENV{$v}))
    {
      return $ENV{$v};
    }
  return '';
}

sub initialize_variables
{
  $t = 1;
  $nil = 0;

  # This is perhaps a little too specific, but some MTAs do not
  # quote 'From ' at the beginning of a line in the body, especially
  # when writing to archive files.
  $re_message_delimiter = '^From [^ ]+ ... ... .. ..:..';

  # According to RFC822, "The field-name must be composed of printable
  # ASCII characters (i.e. characters that have decimal values between 33
  # and 126, except colon)", i.e. any chars except ctl chars, space, or colon.
  $re_header_name = '[][!"#$%&\'()*+,-./0-9;<=>?@A-Z\\^_`a-z{|}~]+';

  # However, these are the characters allowed in FROM_FORMAT specifier
  # header names; some restrictions exist for the sake of formatting.
  $re_fmt_header_name = '[!"#$&\'*+,-./0-9;<=>?@A-Z\\^_`a-z{|}~]+';
  #$re_fmt_header_name = '[][!"#$%&\'()*+,-./0-9;<=>?@A-Z\\^_`a-z{|}~]+';

  $re_blank_line = '(^' . $re_whitespace . '$)|(^$)';
  $re_format_modifier = '%[0-9.-]*';
  $re_whitespace = "[ \f\n\r\t]+";

  $hack_header_function{'FROM'} = 'hack_From_data';
  $hack_header_function{'DATE'} = 'hack_Date_data';

  $format_token{'{TLINES}'} = 'd';
  $format_token{'{FLINES}'} = 'd';

  if (&getenv ("FROM_PARSEP") eq "t")
    {
      $hack_data = $t;
    }
  else
    {
      $hack_data = $nil;
    }

  $total_message_lines = 0;
  $in_message_body_p = $nil;
  $exit_status = 0;

  $columns = &getenv ('COLUMNS');
}

sub make_format_vector
{
  local ($format) = @_;
  local ($fstring, $tmp, $i, $modifier, $tok) = ($format, '', 0);
  local ($re_token) = "$re_format_modifier" . "[^%]*";

  undef (%header_save_p);
  undef (%vector_header_name);
  undef (@format_vector);

  # Here we temporarily disable multi-line scanning ($* = 0) and do not use
  # /(re)|(re)/, but rather use two pattern matching comparisons.  This is
  # because otherwise perl will use ^ to match the beginning of any line,
  # not just the beginning of the string.  What a pain.
  $* = 0;
  while ($fstring =~ /^[^%]+/o || $fstring =~ /^%%/o)
    {
      $tmp = $tmp . $&;
      $fstring = $';
    }
  $* = 1;

  $vector_header_name[0] = 'prefix';
  $format_vector[0] = $tmp;

  while ($fstring =~ /^$re_token/o)
    {
      $i++;
      $modifier = "";
      $tmp = $&;
      $fstring = $';

      if ($tmp =~ /$re_format_modifier/o)
        {
          $modifier = $&;
          $tmp = $';
          if ($tmp =~ /$re_fmt_header_name/o)
            {
              $tmp = $&;
              $trailing_whitespace = $';
            }
          else
            {
              $trailing_whitespace = "";
            }
        }

      $* = 0;
      while ($fstring =~ /^[^%]+/o || $fstring =~ /^%%/o)
        {
          $trailing_whitespace = $trailing_whitespace . $&;
          $fstring = $';
        }
      $* = 1;

      # Make header name all upper case to distinguish from extraneous data
      # like the `prefix' element.
      $tmp = "\U$tmp";

      if (defined ($format_token{$tmp}))
        {
          $tok = $format_token{$tmp};
        }
      else
        {
          $tok = 's';
        }

      $header_save_p{$tmp} = 1;
      $vector_header_name[$i] = $tmp;
      $format_vector[$i] = $modifier . $tok . $trailing_whitespace;
    }
}

sub process_file
{
  local ($file) = @_;

  if (! open (F, "<$file"))
    {
      &err ("open", $file, "$!");
      return;
    }

  $folder_message_lines = 0;

  while (<F>)
    {
      chop $_;

      # If we hit an RFC822 message delimiter, clean up in preparation for
      # getting info about the next message.
      if ($_ =~ /$re_message_delimiter/o)
        {
          undef (%current_headers);
          $in_message_body_p = $nil;
          next;
        }

      # If we're not in the message body, and we come upon a blank line,
      # we're at the end of the headers for this message.
      if ( $_ =~ /$re_blank_line/o && ! $in_message_body_p )
        {
          $total_message_lines++;
          $folder_message_lines++;
          $current_headers{'{TLINES}'} = $total_message_lines;
          $current_headers{'{FLINES}'} = $folder_message_lines;
          $current_headers{'{FOLDER}'} = $file;

          &print_headers (%current_headers);
          $in_message_body_p = $t;
          next;
        }

      if ( $in_message_body_p )
        {
          next;
        }

      &add_header ($_);
    }
  close (F);
}

sub add_header
{
  local ($line) = @_;
  local ($header, $data);

  if (! ($line =~ /^[^ :]*: /o))
    {
      return;
    }

  $header = "\U$&";
  # Get rid of trailing `: ';
  substr ($header, -2) = '';

  if (defined ($header_save_p{$header}))
    {
      $data = $';
      if ($hack_data && defined ($hack_header_function{$header}))
        {
          local ($fn) = $hack_header_function{$header};
          $data = &$fn ($data);
        }

      $current_headers{$header} = $data;
    }
}

# Try to extract real name from From: line when possible
sub hack_From_data
{
  local ($data) = @_;

  # From: foobar@host (real name)
  # From: "real name" <foobar@host>
  if ($data =~ /\([^)]+\)|(\"[^\"]+\")/o)
    {
      $data = $&;
      # Delete leading and trailing name delimiters (quotes or parens)
      substr ($data, 0, 1) = '';
      substr ($data, -1) = '';
      return $data;
    }

  # From: "" <foobar@host>
  if ($data =~ /\"\"[^<]*<[^>]+>/o)
    {
      $data =~ /"<[^>]+>"/;
      $data = $&;
      substr($data, 0, 1) = '';
      substr($data, -1) = '';
      return $data;
    }

  # From: real name <foobar@host>
  if ($data =~ /^[^<]+</o)
    {
      $data = $&;
      chop $data;
      return $data;
    }

  # From: foobar@host
  return $data;
}

# Prettify date
sub hack_Date_data
{
  local ($data) = @_;
  local (@fields, $time, $maxfield, $n);

  @fields = split(/$re_whitespace/o, $data);
  $maxfield = $#fields;

  # Some dates don't have the name of the day of the week at the
  # beginning or the timezone at the end.
  $n = 0;
  if ($maxfield == 4 || $maxfield == 3)
    {
      $n = -1;
    }
  @time = split (/:/, $fields[$n + 4]);

  return sprintf("%s %-2.2d %2.2d:%-2.2d",
                 $fields[$n + 2],
                 $fields[$n + 1],
                 $time[0],
                 $time[1]);
}

sub print_headers
{
  local (%data) = @_;
  local ($format, $header, $str, $num);
  local ($i) = 0;

  while (1)
    {
      if (! (defined ($format_vector[$i])))
        {
          # Truncate output string if appropriate.
          if ($columns > 0 && length ($str) > $columns)
            {
              # Specifying a limit field here (length($str)) prevents the
              # split function from throwing away null fields, which could
              # happen if there are sequential newlines.
              # We certainly cannot have more than length($str) fields.
              local (@lines) = split (/\n/, $str, length ($str));
              local ($len) = $#lines;
              local ($i) = 0;

              while ($i <= $len)
                {
                  if (length ($lines[$i]) > $columns)
                    {
                      $lines[$i] = substr ($lines[$i], 0, $columns);
                    }
                  $i++;
                }

              $str = join ("\n", @lines);
            }
          print "$str";
          return;
        }

      $header = $vector_header_name[$i];
      $format = $format_vector[$i];
      if ($format =~ /\\/o)
        {
          eval "\$format = \"$format\"";
        }

      $str = $str . sprintf ($format, $data{$header});
      $i++;
    }
}

__EOF__

# local variables:
# mode: perl
# eval: (auto-fill-mode 1)
# end:

# from ends here
