#!/bin/sh
# mkdirhier --- make directory hierarchy
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1992-01-10
# Public domain

# $Id: mkdirhier,v 1.3 1995/09/23 17:30:33 friedman Exp friedman $

# Commentary:
# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

usage="Usage: $progname {options} [directory-path {...}]

Options are:
-D, --debug                  Turn on shell debugging ($bq${bq}set -x$eq$eq).
-h, --help                   You're looking at it.
-v, --verbose                Print new directory names as they're made.
"

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
debug=
verbose=

# If --verbose is specified, fd 3 is duped to fd 1 instead.
exec 3> /dev/null

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while test $# != 0; do
  case "$1" in
    -D | --debug | --d* )
      debug=t
      shift
     ;;
    -h | --help | --h )
      echo "$usage" 1>&2
      exit 1
     ;;
    -v | --verbose | --v* )
      exec 3>&1
      shift
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -* )
      case "$1" in
        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
        * )     arg="$1" ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in t ) set -x ;; esac

errstatus=0

for file in ${1+"$@"}; do
  # If filename begins with a `-', put `./' in front of it to avoid
  # confusing mkdir.
  case "$file" in
    -* ) file="./$file" ;;
  esac

  oIFS="$IFS"
  IFS='/'
  set fnord $file
  IFS="$oIFS"
  shift

  case "$file" in
    /* ) pathcomp=/ ;;
    *  ) pathcomp=  ;;
  esac

  for d in ${1+"$@"}; do
    pathcomp="$pathcomp$d"

    if test ! -d "$pathcomp" ; then
      echo "$pathcomp" 1>&3
      mkdir "$pathcomp" || errstatus=$?
    fi

    pathcomp="$pathcomp/"
  done
done

exit $errstatus

# mkdirhier ends here
