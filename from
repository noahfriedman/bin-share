#!/usr/local/bin/gawk -f
# From - show you who your mail is from.
# 19-Jan-92 Noah Friedman <friedman@prep.ai.mit.edu>
# Last modified 27-Mar-93 (alpha test)
# Public domain
#

function initialize_variables ()
{
    NULL=""
    mail_spool_directory="/usr/spool/mail"

    t = 1
    nil = 0

    re_message_delimiter="^From .*"
    re_whitespace = "[ \a\b\f\n\r\t\v]+"
    re_blank_line= "(^" re_whitespace "$)|(^$)"
    re_format_modifier = "%[0-9-.]*"

    if (getenv("MAIL") == NULL)
       putenv("MAIL", mail_spool_directory "/" getenv("USER"));

    if (getenv("COLUMNS") == NULL)
       putenv("COLUMNS", "80");

    if (getenv("FROM_FORMAT") == NULL)
       putenv("FROM_FORMAT", "%-19.18From %-13.12Date %-." getenv("COLUMNS") - 35 "Subject")

    in_message_body_p = nil
    hack_data = 1;  # Not user-settable yet
}

function parse_command_args ()
{
    # Don't need this, and it's a pain.
    delete ARGV[0];
    for (i = 1; i < ARGC; i++) {
       if (ARGV[i] == "+f" || ARGV[i] == "+format") {
          putenv("FROM_FORMAT", ARGV[i + 1]);
          ARGV[i] = ""; ARGV[++i] = "";
          continue;
       }
       if (ARGV[i] == "+u" || ARGV[i] == "+user") {
          putenv("USER", ARGV[i + 1]);
          putenv("MAIL", mail_spool_directory "/" getenv("USER"));
          ARGV[i] = ""; ARGV[++i] = "";
          continue;
       }
       if (ARGV[i] == "+h" || ARGV[i] == "+hack") {
          hack_data = 0;
          ARGV[i] = ""; 
          continue;
       }
    }
    no_files_p = 1;
    for (i in ARGV) {
       if (ARGV[i] != "") {
          # Eliminate any file we can't open for reading. 
          if (!file_readable_p(ARGV[i]))
             ARGV[i] = "";
          else
             no_files_p = 0;
          break;
       }
    }
    # No empty slots.  Create one (let loop below insert default mailbox)
    # Must increment ARGC, as awk will never look ARGV[i] for i > ARGC
    if (ARGC == 1) {
       ARGV[1] = "";      # Allocate it
       ARGC++;
    }
    if (no_files_p == 1) {
       # Look for an empty slot to add file
       for (i in ARGV)
          if (ARGV[i] == "") {
             ARGV[i] = getenv("MAIL");
             # If default mailbox isn't there, punt quietly (but with
             # nonzero exit status
             if (!file_readable_p(ARGV[i]))
                exit 1
             break;
          }
    }
}

function cons_important_header_array (format,     fstring, format_modifier, tmp)
{
    i = 0;
    fstring = format;
    if (match(fstring, "^[^%]*"))
       important_header_array["prefix"] = substr(fstring, RSTART, RLENGTH);
    while (match(fstring, re_format_modifier "[^%]*")) {
       i++;
       format_modifier=""
       tmp = substr(fstring, RSTART, RLENGTH);
       fstring = substr (fstring, RSTART + RLENGTH);
       if (match(tmp, re_format_modifier)) {
          format_modifier = substr(tmp, RSTART, RLENGTH);
          tmp = substr(tmp, RSTART + RLENGTH);
          if (match(tmp, re_whitespace)) {
             trailing_whitespace = substr(tmp, RSTART);
             tmp = substr(tmp, 0, RSTART - 1);
          } else trailing_whitespace="";
       }      
       important_header_array[tmp] = format_modifier "s" trailing_whitespace;
       important_header_order[i] = tmp;
    }
}

function add_header (line, header_array,    header, data)
{
    if (match(line, "^[^ :]*:") == 0) return;
    header = substr(line, RSTART, RLENGTH - 1);

    if (header in important_header_array) {
       data = substr (line, RSTART + RLENGTH + 1);
       if (hack_data && header == "From")
          data = hack_From_data(data);
       if (hack_data && header == "Date")
          data = hack_Date_data(data);
       header_array[header] = data;
    }
}

# Try to extract real name from From: line when possible
function hack_From_data (data)
{
    # From: foobar@host (real name)
    # From: "real name" <foobar@host>
    if (match(data, "\\([^)]+\\)|\"[^\"]+\"")) {
       data = substr(data, RSTART + 1, RLENGTH - 2);
       return data;
    }
    # From: "" <foobar@host>
    if (match(data, "\"\"[^<]*<[^>]*>")) {
       match(data, "<[^>]*>");
       data = substr(data, RSTART + 1, RLENGTH - 2);
       return data;
    }
    # From: real name <foobar@host>
    if (match(data, "^[^<]+")) {
       data = substr(data, RSTART, RLENGTH);
       return data;
    }
    return data
}

# Prettify date
function hack_Date_data (data,   fields, time)
{
    num_fields = split(data, fields, re_whitespace);
    # Some dates don't have the name of the day of the week at the
    # beginning or the timezone at the end. 
    n = 0;
    if (num_fields == 5 || num_fields == 4) n = -1; 
    split(fields[n + 5], time, ":");
    return sprintf("%s %-2s %2s:%-2s", fields[n + 3], fields[n + 2], time[1], time[2]);
}

function delete_array (array,   array_index)
{
    for (array_index in array) 
       delete array[array_index];
}

function print_headers (header_array,    format, header, i)
{
   i = 1; 
   printf("%s", important_header_array["prefix"]);
   while (1) {
      if (!(i in important_header_order)) {print ""; return; }
      header = important_header_order[i];
      printf(important_header_array[header], header_array[header]);
      i++;
   }
}

function file_readable_p (file,     status)
{
   status = system("test -r " file);
   if (status == 0)
      return 1
   return 0
}

function getenv (var)
{
    if (var in ENVIRON)
       return ENVIRON[var]
    return NULL
}

function putenv (var, value)
{
    ENVIRON[var] = value;
}

BEGIN {
    initialize_variables();
    parse_command_args();
    cons_important_header_array(getenv("FROM_FORMAT"));
}

{
    # If we hit an RFC822 message delimiter, clean up in preparation for
    # getting info about the next message.
    if ( $0 ~ re_message_delimiter ) {
       delete_array(headers);
       in_message_body_p = nil;
       next;
    }

    # If we're not in the message body, and we come upon a blank line,
    # we're at the end of the headers for this message.
    if ( $0 ~ re_blank_line && ! in_message_body_p ) {
       print_headers(headers);
       in_message_body_p = t;
       next;
    }

    if ( in_message_body_p ) next;

    add_header($0, headers);
}

#
# eof
#
