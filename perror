#!/usr/bin/env perl
# perror --- show system error messages from symbolic or numeric errno values
# Author: Noah Friedman <friedman@splode.com>
# Created: 2002-03-16
# Public domain

# $Id: perror,v 1.3 2003/02/21 05:18:16 friedman Exp $

# Commentary:
# Code:

$^W = 1; # enable warnings

use POSIX qw(:errno_h);
use strict;

my @errno_data;
my %errno_data;

sub init
{
  my $tags = $POSIX::EXPORT_TAGS{errno_h};

  for my $errname (@$tags)
    {
      next if $errname eq q(errno);

      my $errnum = eval { no strict qw(refs); &$errname };
      next unless defined $errnum;
      local $! = $errnum;
      my $errmsg = $! . "";

      (my $altname = $errname) =~ s/^E//o;

      my $data = [$errname, $errnum, $errmsg];
      push @errno_data, $data;
      $errno_data{$errnum}     = $data;
      $errno_data{$errname}    = $data;
      $errno_data{lc $errname} = $data;
      $errno_data{$errmsg}     = $data;
      $errno_data{lc $errmsg}  = $data;
      $errno_data{$altname}    = $data;
      $errno_data{lc $altname} = $data;
    }
}

sub printmatches
{
  my $data = shift;
  map { printf "%s\t%d\t%s\n", @$_ }
      sort { $a->[1] <=> $b->[1] } @$data;
}

sub main
{
  init ();
  unless (@ARGV)
    {
      printmatches (\@errno_data);
      exit (0);
    }

  my %match;
  for my $arg (@ARGV)
    {
      if ($arg =~ m|^/(.*?)/$|o)
        {
          my $pat = $1;
          map { $match{$_} = $_
                  if ($_->[0] =~ /$pat/i
                      || $_->[1] =~ /$pat/i
                      || $_->[2] =~ /$pat/i);
              } @errno_data;
        }
      else
        {
          my $data = $errno_data{$arg};
          $match{$data} = $data if defined $data;
        }
    }
  printmatches ([values %match]) if %match;
}

main ();

# perror ends here
