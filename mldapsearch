#!/usr/bin/env perl
# mldapsearch --- my ldapsearch implementation

# Author: Noah Friedman <friedman@splode.com>
# Created: 2012-09-28
# Public domain.

# $Id: mldapsearch,v 1.2 2012/09/29 00:40:23 friedman Exp $

use Net::LDAP;
use Getopt::Long;
use strict;

$^W = 1;

our %opt = ( host    => "ldap",
             scope   => 'sub',
             onerror => 'die',
             verify  => 'none',
           );

sub parse_options
{
  local *ARGV = \@{$_[0]}; # modify our local arglist, not real ARGV.

  my $parser = Getopt::Long::Parser->new;
  $parser->configure (qw(bundling autoabbrev));
  my $succ = $parser->getoptions
    ( "debug:i"        => \$opt{debug},
      "b|root|base=s"  => \$opt{base},
      "h|host=s",      => \$opt{host},
      "D|bind=s",      => \$opt{bind},
      "w|pswd|pass=s", => \$opt{password},
      "p|port=s",      => \$opt{port},
      "s|scope=s",     => \$opt{scope},
      "P|cert=s"       => \$opt{cafile},
    );

  $opt{debug} = 1 if defined $opt{debug} && $opt{debug} == 0;
  if ($opt{debug})
    {
      my $n = 0;
      map { $n = ($n << 1) | $_ } split //, $opt{debug};
      $opt{debug} = $n;
    }
}

# Query server to find out what directory roots are available, and if more
# than one, use hostname's fqdn to guess most likely relevant one.
sub baseDN
{
  my @nc = $_[0]->root_dse->get_value ("namingContexts");
  map { return $_ unless lc $_ eq "o=netscaperoot" } @nc if @nc <= 2;

  use POSIX qw(uname);
  my $nodename = (uname())[1];
  unless ($nodename =~ /\./) { # try to get FQDN
    my @n = gethostbyname ($nodename);
    if (@n) {
      for my $h ($n[0], split (/\s+/, $n[1])) {
        if ($h =~ /\./) {
          $nodename = $h;
          last;
        }
      }
    }
  }
  my @dc = split (/\./, lc $nodename);
  # Create "normalized" table by forcing lcase and stripping whitespace
  my %nc = map { my $key = lc $_;
                 $key =~ s/\s+//g;
                 $key => $_ ;
               } @nc;
  # Search for "dc=foo,dc=com" and "o=foo.com"
  map { map { return $nc{$_} if exists $nc{$_}
            } (join (",", map { "dc=$_" } @dc),
               "o=" . join (".", @dc));
        shift @dc;
      } @dc;

  return @nc[0]; # if all else fails, return first advertised.
}

sub main
{
  parse_options (\@_);
  my $ldap = Net::LDAP->new ($opt{host}, %opt) || die "$@\n";
  $ldap->bind ($opt{bind}, %opt) if defined $opt{bind};

  $_[0] = sprintf ("uid=%s", $_[0]) unless $_[0] =~ /=/;
  my (@srch, @attr);
  map { my $array = /=/ ? \@srch : \@attr;
        push @$array, $_
      } @_;

  my $filter = sprintf ("(|%s)", join ("", map { /^\(/ ? $_ : "($_)" } @srch));
  $opt{filter} = $filter;

  $opt{attrs} = \@attr if @attr;
  $opt{base} = baseDN ($ldap) unless defined $opt{base};

  my $result = $ldap->search (%opt);
  print $_->ldif while $_ = $result->shift_entry;
}

main (@ARGV);

1;
