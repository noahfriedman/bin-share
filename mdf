#!/bin/sh
# mdf --- df wrapper to align columns for legibility

# Author: Noah Friedman <friedman@splode.com>
# Created: 2001-01-11
# Public domain.

# $Id$

# Commentary:
# Code:

exec ${PERL-perl} -Sx $0 ${1+"$@"}
#!perl

use strict;

my $fieldsep = "[ \t]+";
my %right_justify = ( 1 => 1, 2 => 1, 3 => 1, 4 => 1);
my $width_limit;  # not currently used
my $widthpad = 1; # extra padding to add between columns

sub parse_input ($$)
{
  my $lines = shift;
  my $fieldsep = shift;
  my @parsedlines;
  my @maxwidth;

  my $line;
  foreach $line (@$lines)
    {
      my @fields = split (/$fieldsep/o, $line, -1);
      push @parsedlines, \@fields;

      my $i = 0;
      my $f;
      foreach $f (@fields)
        {
          my $l = length $f;
          $maxwidth[$i] = $l if ($l > $maxwidth[$i]);
          $i++;
        }
    }
  return \@parsedlines, \@maxwidth;
}

sub print_output ($$)
{
  my ($lines, $maxwidth) = @_;

  my @fmts;
  my $i = 0;
  my $width;
  foreach $width (@$maxwidth)
    {
      my $w = (defined $width_limit ? min ($width, $width_limit) : $width);
      push @fmts, join ("",
                        $i == 0 ? "" : " " x $widthpad,
                        (exists $right_justify{$i} ? "%" : "%-"),
                        $w,
                        (defined $width_limit ? "." . ($w-1) : ""),
                        "s");
      $i++;
    }
  $fmts[$#fmts] = "%s" if (substr ($fmts[$#fmts], 1, 1) eq '-');
  my $fmtstr = join (" ", @fmts);

  foreach my $l (@$lines)
    {
      my $s = sprintf ($fmtstr, @$l);
      $s =~ s/\s+$//o;
      print $s, "\n";
    }
}

sub main ()
{
  my $dfcmd = exists $ENV{DF} ? $ENV{DF} : 'df';
  push @ARGV, "-k" unless (scalar @ARGV > 0);
  my @dfout = qx{ $dfcmd @ARGV };

  my $header = shift @dfout;
  $header =~ s/Mounted on/Mountpoint/o;

  my $dfout = join ("", @dfout);
  $dfout =~ s/\n\s+/ /go;
  @dfout = sort split (/\n/o, $dfout);
  unshift @dfout, $header;

  my ($lines, $fieldsep) = parse_input (\@dfout, $fieldsep);
  print_output ($lines, $fieldsep);
}

main ();

# local variables:
# mode: perl
# eval: (auto-fill-mode 1)
# end:

# mdf ends here
