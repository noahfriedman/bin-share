#!/bin/sh
exec ${PERL-perl} -wSx $0 ${1+"$@"}
#!perl

# fmtcols --- indent columns so they line up

# Copyright (C) 1997, 2000 Noah S. Friedman

# Author: Noah Friedman <friedman@splode.com>
# Created: 1997-08-02

# $Id: fmtcols,v 2.7 2001/02/19 21:47:12 friedman Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.

# Commentary:
# Code:

use Getopt::Long;
use Symbol;
use strict;

sub min { return [ sort {   $a <=> $b  } @_ ]->[0]; }
sub max { return [ sort { -($a <=> $b) } @_ ]->[0]; }

# This function reads blocks of data into a buffer and then calls an
# anonymous subroutine with a reference to the data.  That subroutine
# should return the offset of any unexamined data remaining so that it can
# be prepended to the next block of read data; in this way, data which
# fails to match a regexp because it was truncated should be successfully
# matched next time.  (It also may return -1 to indicate discarding all
# existing data.)
#
# Surprisingly, doing repeated global regexp matching on a buffer instead
# of reading line-at-a-time, eliminates an extra copy and tends to make
# scanning a little bit faster than using line-at-a-time with <$fh>.
sub map_over_file_contents ($@)
{
  my $fn = shift;
  my $fh = gensym;
  my $blocksize = 10 * 1024 * 1024; # 10mb

  my $file;
  foreach $file (@_)
    {
      if ($file eq "-")
        {
          open ($fh, "<&STDIN");
        }
      elsif (!sysopen ($fh, $file, 0))
        {
          die join (": ", $file, "$!");
        }

      my $bytesread = $blocksize;
      my $offset = 0;
      $_ = "";
      while (defined $bytesread && $bytesread > 0)
        {
          my $len = length;
          $_ = substr ($_, $offset)
            if ($offset > 0 && $offset < $len);
          $_ = "" if ($offset < 0 || $offset >= $len);
          $bytesread = sysread ($fh, $_, $blocksize, length);
          $offset = &$fn (\$_) || 0;
        }
      close ($fh);
    }
}

sub read_input ($$@)
{
  my $fieldsep = shift;
  my $numfields = shift;
  my @line;
  my @maxwidth;

  $numfields = -1 unless (defined $numfields);

  map_over_file_contents
    sub {
      while (${$_[0]} =~ m/(.*)\n/gmo)
        {
          my @fields = split (/$fieldsep/o, $1, $numfields);
          my $i = 0;

          push @line, \@fields;
          my $f;
          foreach $f (@fields)
            {
              my $l = length $f;
              $maxwidth[$i] = $l
                if (!defined $maxwidth[$i] || $l > $maxwidth[$i]);
              $i++;
            }
        }
      return pos ${$_[0]};
    }, @_;
  return \@line, \@maxwidth;
}

sub print_output ($$$$$$)
{
  my ($line, $fieldsep, $outsep, $maxwidth, $width_limit, $right_justify) = @_;

  my @fmts;
  my $i = 0;
  my $width;
  foreach $width (@$maxwidth)
    {
      my $w = (defined $width_limit ? min ($width, $width_limit) : $width);
      push @fmts, join ("",
                        (exists $right_justify->{$i} ? "%" : "%-"),
                        $w,
                        (defined $width_limit ? "." . ($w-1) : ""),
                        "s");
      $i++;
    }
  $fmts[$#fmts] = "%s" if (substr ($fmts[$#fmts], 1, 1) eq '-');
  my $fmtstr = join ($outsep, @fmts);

  my $l;
  foreach $l (@$line)
    {
      my $s = sprintf ($fmtstr, @$l);
      $s =~ s/\s+$//o;
      print $s, "\n";
    }
}

sub parse_options ()
{
  my $fieldsep    = "[ \t]+";
  my $outsep      = " ";
  my $num_fields;
  my $width_limit;
  my %right_justify;
  my @rightcols;

  Getopt::Long::config ('bundling', 'autoabbrev');
  GetOptions ("n|num-fields=i",       \$num_fields,
              "m|max-field-width=i",  \$width_limit,
              "r|right-justify=s@",   \@rightcols,
              "S|output-separator=s", \$outsep,
              "s|separator=s",        \$fieldsep,
              "h|help",               \&usage);

  my $col;
  foreach $col (split (/\s*,\s*/o, join (",", @rightcols)))
    {
      $right_justify{$col} = 1;
    }

  return ($fieldsep, $outsep, $width_limit, $num_fields, \%right_justify);
}

sub usage ()
{
  $0 =~ s|.*/||;
  print "Usage: $0 {options} [files {...}]\n
Options are:
-h, --help                      You're looking at it.
-r, --right-justify  F0,F1,...  Right-justify fields F0, F1, ...
-s, --separator        SEP      Field separator between columns.
                                This can be any regular expression.
                                The default field separator is any number of
                                tabs and spaces, i.e. \"[ \\t]+\".
-S, --output-separator SEP      Output separator between fields.  Default \" \".
-n, --num-fields       NUM      Assume there are no more than NUM fields.
                                If there are more, last column contains all
                                remaining elements.
-m, --max-field-width  MAX      Truncate fields on output that are larger than
                                this limit.  By default, there is no limit.\n";
  exit (1);
}

sub main
{
  my ($fieldsep, $outsep, $width_limit, $numfields, $align) = parse_options ();
  push @ARGV, "-" unless (scalar @ARGV > 0);
  my ($lines, $maxwidth) = read_input ($fieldsep, $numfields, @ARGV);
  print_output ($lines, $fieldsep, $outsep, $maxwidth, $width_limit, $align);
}

main ();

# local variables:
# mode: perl
# eval: (auto-fill-mode 1)
# end:

# fmtcols ends here
