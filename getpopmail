#! /bin/sh
# getpopmail --- retrieve POP mail

# Copyright (C) 1996 Noah S. Friedman

# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1996-02-27

# $Id: getpopmail,v 2.1 1996/04/22 01:57:25 friedman Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.

# Commentary:

# This program has two external program dependencies.
# 1) You must have my modified `popclient' program (unmodified source is
#    available from the Linux Slackware source distribution and other
#    locations).  My copy is available via the URL
#    ftp://alpha.gnu.ai.mit.edu/friedman/packages/popclient.tar.gz
#    In particular, my version accepts a -P option which reads the remote
#    password from standard input instead of the tty.
#
# 2) An external script called `network-up-p' which tests to see if the pop
#    servers or network in general are reachable.

# This script reads a configuration file with lines of the form
#
#     server : user : password : protocol : flags
#
# Where
#        `server is the pop server
#        `user'  is the user name on the pop server
#        `password' is the user's password on the pop server
#        `protocol' is the POP protocol used (either 2 or 3)
#        `flags' are additional flags to `popclient', e.g. `-k'.
#
# Anything after a `#' character in the configuration file is considered a
# comment.  Excess whitespace and blank lines are ignored.
#
# The configuration file can be specified with the `--config' option, the
# GETPOPMAILCF environment variable, or $HOME/.getpopmail.cf by default.

# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

usage="Usage: $progname {options}

Options are:
-D, --debug                  Enable debugging.
-c, --config    FILE         Use configuration file FILE.
-h, --help                   You're looking at it.
-q, --quiet                  Discard all output.
                             This is the default if stdin is not a tty.
-v, --verbose                Be verbose.
                             This is the default if stdin is a tty.
"

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.

PATH="$PATH:/usr/local/bin"
export PATH

GETPOPMAILCF=${GETPOPMAILCF-$HOME/.getpopmail.cf}
export GETPOPMAILCF

debug=

if [ -t 0 ]; then
  verbose=t
else
  verbose=
fi

# Usage: eval "$getopt"; value=$optarg
# or     optarg_optional=t; eval "$getopt"; value=$optarg
#
# This function automatically shifts the positional args as appropriate.
# The argument to an option is optional if the variable `optarg_optional'
# is non-empty.  Otherwise, the argument is required and getopt will cause
# the program to exit on an error.  optarg_optional is reset to be empty
# after every call to getopt.  The argument (if any) is stored in the
# variable `optarg'.
#
# Long option syntax is `--foo=bar' or `--foo bar'.  2nd argument
# won't get used if first long option syntax was used.
#
# Note: because of broken bourne shells, using --foo=bar syntax can
# actually screw the quoting of args that end with trailing newlines.
# Specifically, most shells strip trailing newlines from substituted
# output, regardless of quoting.
getopt='
  {
    optarg=
    case "$1" in
      --*=* )
        optarg=`echo "$1" | sed -e "1s/^[^=]*=//"`
        shift
       ;;
      * )
        case ${2+set} in
          set )
            optarg="$2"
            shift
            shift
           ;;
          * )
            case "$optarg_optional" in
              "" )
                case "$1" in
                  --*=* ) option=`echo "$1" | sed -e "1s/=.*//;q"` ;;
                  * ) option="$1" ;;
                esac
                exec 1>&2
                echo "$progname: option $bq$option$eq requires argument."
                echo "$progname: use $bq--help$eq to list option syntax."
                exit 1
               ;;
           esac
           shift
         ;;
        esac
     ;;
    esac
    optarg_optional=
  }'

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while : ; do
  case $# in 0) break ;; esac
  case "$1" in
    -D | --debug | --d* )
      debug=-d
      shift
     ;;
    # Provided as an example of how to process options with arguments
    -c | --config* | --c* )
      eval "$getopt"
      GETPOPMAILCF="$optarg"
     ;;
    -h | --help | --h* )
      echo "$usage" 1>&2
      exit 0
     ;;
    -q | --quiet | --q* )
      verbose=
      shift
     ;;
    -v | --verbose | --v* )
      verbose=t
      shift
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -? | --* )
      case "$1" in
        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
        * )     arg="$1" ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    -??* )
      # Split grouped single options into separate args and try again
      optarg="$1"
      shift
      set fnord `echo "x$optarg" | sed -e 's/^x-//;s/\(.\)/-\1 /g'` ${1+"$@"}
      shift
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in -d ) set -x ;; esac

case "$verbose" in
  t ) : ;;
  * ) exec > /dev/null 2>&1 < /dev/null ;;
esac

network-up-p || exit $?

# By using a here-document to include the source of the perl script (to
# avoid command line length limits), we usurp the normal stdin the inferior
# process might have expected.  So dup stdin onto fd 9, and before the
# inferior process is started, it will be reduped back onto fd 0.
exec ${PERL-perl} - 9<&0 <<'__EOF__'

&main;

sub main
{
  $0 = 'getpopmail';

  @ARGV = ($ENV{'GETPOPMAILCF'});

  # See comments preceding perl invocation for an explanation.
  if (! open (STDIN, "<&9"))
    {
      &errmsg ("cannot recover stdin from fd 9", "$!");
      exit (1);
    }
  close (9);

  while (<>)
    {
      local (@tok) = &parse_line ($_);

      next if ($tok[0] eq '');

      if (&network_up_p ($tok[0]))
        {
          &popclient (@tok);
        }

    }
}

sub parse_line
{
  local ($line) = @_;
  local ($i, @tok);

  chop $line;
  $line =~ s/[ \t]*#.*//o;

  # We might want embedded whitespace in fields
  #@tok = split (/[ \t:]+/, $line);
  @tok = split (/:/, $line);
  $i = 0;
  while ($i <= $#tok)
    {
      # Strip leading and trailing whitespace
      $tok[$i] =~ s/^[ \t]+//o;
      $tok[$i] =~ s/[ \t]+$//o;
      $i++;
    }

  return @tok;
}

sub network_up_p
{
  if (&spawn ('network-up-p', '-v', @_) == 0)
    {
      return 1;
    }
  return 0;
}

# This function doesn't use spawn since it must set up some pipes to feed
# passwords to the popclient.
sub popclient
{
  local ($server, $user, $pw, $protocol, $flags) = @_;
  local ($pid);

  pipe (POPREAD, POPWRITE);
  $pid = fork;

  if (! defined $pid)
    {
      die "Can't fork: $!\n";
    }

  if ($pid == 0)
    {
      # child
      open (STDIN, "<&POPREAD");
      close (POPWRITE);
      close (POPREAD);
      exec ('popclient', '-u', $user, '-P', "-v$protocol$flags", $server);
    }
  else
    {
      # parent
      print POPWRITE $pw . "\n";
      close (POPWRITE);
      close (POPREAD);
      wait;
      return $?
    }

}

sub spawn
{
  local (@args) = @_;
  local ($pid) = fork;

  if (! defined $pid)
    {
      die "Can't fork: $!\n";
    }

  if ($pid == 0)
    {
      # child
      exec (@args);
    }
  else
    {
      # parent
      wait;
      return $?
    }
}

__EOF__

# eof
