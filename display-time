#! /bin/sh
# display-time --- mode-line data accumulator for my time.el
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1991-12-18

# $Id: display-time,v 1.10 1995/09/23 22:00:11 friedman Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.

# Commentary:
# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

# Substitute your usage string here.
usage="Usage: $progname {options}

Options are;
-D, --debug                  Turn on shell debugging (${bq}set -x$eq).
-h, --help                   You're looking at it.
-l, --load-average           Print present load average.
-m, --mail                   Print number of spooled messages.
-s, --sleep SECONDS          Sleep SECONDS between each check.
"

# Usage: eval "$getopt"; value=$optarg
# or     optarg_optional=t; eval "$getopt"; value=$optarg
#
# This function automatically shifts the positional args as appropriate.
# The argument to an option is optional if the variable `optarg_optional'
# is non-empty.  Otherwise, the argument is required and getopt will cause
# the program to exit on an error.  optarg_optional is reset to be empty
# after every call to getopt.  The argument (if any) is stored in the
# variable `optarg'.
#
# Long option syntax is `--foo=bar' or `--foo bar'.  2nd argument
# won't get used if first long option syntax was used.
#
# Note: because of broken bourne shells, using --foo=bar syntax can
# actually screw the quoting of args that end with trailing newlines.
# Specifically, most shells strip trailing newlines from substituted
# output, regardless of quoting.
getopt='
  {
    optarg=
    case "$1" in
      --*=* )
        optarg=`echo "$1" | sed -e "1s/^[^=]*=//"`
        shift
       ;;
      * )
        case ${2+set} in
          set )
            optarg="$2"
            shift
            shift
           ;;
          * )
            case "$optarg_optional" in
              "" )
                case "$1" in
                  --*=* ) option=`echo "$1" | sed -e "1s/=.*//;q"` ;;
                  * ) option="$1" ;;
                esac
                exec 1>&2
                echo "$progname: option $bq$option$eq requires argument."
                echo "$progname: use $bq--help$eq to list option syntax."
                exit 1
               ;;
           esac
         ;;
        esac
     ;;
    esac
    optarg_optional=
  }'

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
debug=
check_loadavg=
check_mail=
sleep_time=60

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while test $# != 0 ; do
  case "$1" in
    -D | --debug | --d* )
      debug=t
      shift
     ;;
    -h | --help | --h* )
      echo "$usage" 1>&2
      exit 1
     ;;
    -l | --load-average | --l* )
      check_loadavg=t
      shift
     ;;
    -m | --mail | --m* )
      check_mail=t
      shift
     ;;
    -s | --sleep* | --s* )
      eval "$getopt"
      sleep_time="$optarg"
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -? | --* )
      case "$1" in
        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
        * )     arg="$1" ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    -??* )
      # Split grouped single options into separate args and try again
      optarg="$1"
      shift
      set fnord `echo "x$optarg" | sed -e 's/^x-//;s/\(.\)/-\1 /g'` ${1+"$@"}
      shift
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in t ) set -x ;; esac

USER=${USER-${LOGNAME-`{ (whoami) 2> /dev/null; } \
                       || { id | sed -ne 's/.*uid=[0-9]*(//
                                          s/).*//
                                          p'
                          }`}}

for f in /usr/spool/mail /var/mail /usr/mail ; do
  if test -d "$f" ; then
    spoolfile="$f/$USER"
    break
  fi
done

mail_result=
prev_spool_stat=

while : ; do
  loadavg_result=
  spool_stat=
  case "$check_loadavg" in t )
    loadavg=`uptime \
              | sed -ne 's/.*load averages*:[ 	]*//
                         s/[, 	].*//
                         p'`
    loadavg_result="loadavg:$loadavg"
   ;;
  esac

  if test ".$check_mail" = .t -a -s "$spoolfile" ; then
    spool_stat=`ls -ld "$spoolfile" 2> /dev/null`
    case "$spool_stat" in
      "$prev_spool_stat" ) : ;;
      * )
        set fnord `grep '^From ' "$spoolfile" 2> /dev/null | wc -l`
        shift
        mail_result="mail:$1"
       ;;
    esac
  else
    mail_result=
  fi

  prev_spool_stat="$spool_stat"

  echo $loadavg_result $mail_result
  sleep "$sleep_time"
done

# display-time ends here
