#! /bin/sh
# tcpconnect --- connect via TCP to a specified host and port

# Copyright (C) 1995, 1996 Noah S. Friedman

# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1995-04-15

# $Id: tcpconnect,v 1.6 1995/09/26 00:42:10 friedman Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.

# Commentary:
# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

usage="Usage: $progname {options} [host {port}]

Options are:
-D, --debug           Turn on interactive debugging in perl.
-h, --help            You're looking at it.
-H, --no-sigup        Do not kill child processes with SIGHUP on EOF.
-I, --include   DIR   Include DIR in @INC path for perl.
                      This option may be specified multiple times to append
                      search paths to perl.
-i, --no-intr         Ignore interrupts (SIGINT).
-d, --no-dynload      Do not attempt to use perl5 dynamic loaded libraries.
                      This option is automatic if you are using perl4 or older.
-R, --no-resolve      Do not attempt to reverse-resolve numeric IP
                      addresses if specified on the command line.
-s, --stty     FLAGS  Run with arbitrary terminal settings,
                      e.g. ${bq}raw$eq, $bq-echo$eq, etc.  All flags will
                      be restored on exit.
-v, --verbose         Report on status of connection.
"

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
debug=
includes=
perl=${TCPCONNECT_PERL-${PERL-perl}}
TCPCONNECT_DYNLOAD=
TCPCONNECT_RESREV=
TCPCONNECT_SIGHUP=
TCPCONNECT_SIGINT=
TCPCONNECT_STTY=
TCPCONNECT_VERBOSE=

# Usage: eval "$getopt"; value=$optarg
# or     optarg_optional=t; eval "$getopt"; value=$optarg
#
# This function automatically shifts the positional args as appropriate.
# The argument to an option is optional if the variable `optarg_optional'
# is non-empty.  Otherwise, the argument is required and getopt will cause
# the program to exit on an error.  optarg_optional is reset to be empty
# after every call to getopt.  The argument (if any) is stored in the
# variable `optarg'.
#
# Long option syntax is `--foo=bar' or `--foo bar'.  2nd argument
# won't get used if first long option syntax was used.
#
# Note: because of broken bourne shells, using --foo=bar syntax can
# actually screw the quoting of args that end with trailing newlines.
# Specifically, most shells strip trailing newlines from substituted
# output, regardless of quoting.
getopt='
  {
    optarg=
    case "$1" in
      --*=* )
        optarg=`echo "$1" | sed -e "1s/^[^=]*=//"`
        shift
       ;;
      * )
        case ${2+set} in
          set )
            optarg="$2"
            shift
            shift
           ;;
          * )
            case "$optarg_optional" in
              "" )
                case "$1" in
                  --*=* ) option=`echo "$1" | sed -e "1s/=.*//;q"` ;;
                  * ) option="$1" ;;
                esac
                exec 1>&2
                echo "$progname: option $bq$option$eq requires argument."
                echo "$progname: use $bq--help$eq to list option syntax."
                exit 1
               ;;
           esac
         ;;
        esac
     ;;
    esac
    optarg_optional=
  }'

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while : ; do
  case $# in 0) break ;; esac
  case "$1" in
    -D | --debug | --de* )
      debug=-d
      shift
      set -x
     ;;
    -d | --no-dynamic-loading | --no-dynload | --no-d* )
      TCPCONNECT_DYNLOAD=nil
      export TCPCONNECT_DYNLOAD
      shift
     ;;
    -H | --no-sighup | --no-s* )
      TCPCONNECT_SIGHUP=nil
      export TCPCONNECT_SIGHUP
      shift
     ;;
    -h | --help | --he* )
      echo "$usage" 1>&2
      exit 0
     ;;
    -I | --include* | --i* )
      eval "$getopt"
      includes="$includes -I$optarg"
     ;;
    -i | --no-intr | --no-in* )
      TCPCONNECT_SIGINT=nil
      export TCPCONNECT_SIGINT
      shift
     ;;
    -R | --no-resolve | --no-reverse-resolve | --no-r* )
      TCPCONNECT_REVRES=nil
      export TCPCONNECT_REVRES
      shift
     ;;
    -s | --stty* | -s* )
      eval "$getopt"
      case "$optarg" in
        *,* ) optarg=`echo "$optarg" | sed 's/,/ /g'` ;;
      esac
      TCPCONNECT_STTY="$optarg"
      export TCPCONNECT_STTY
     ;;
    -v | --verbose | --v* )
      TCPCONNECT_VERBOSE=t
      export TCPCONNECT_VERBOSE
      shift
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -? | --* )
      case "$1" in
        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
        * )     arg="$1" ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    -??* )
      # Split grouped single options into separate args and try again
      optarg="$1"
      shift
      set fnord `echo "x$optarg" | sed -e 's/^x-//;s/\(.\)/-\1 /g'` ${1+"$@"}
      shift
     ;;
    * )
      break
     ;;
  esac
done

case $# in
  0 )
    echo "$usage" 1>&2
    exit 1
   ;;
esac

TCPCONNECT_PROGNAME="$progname"
export TCPCONNECT_PROGNAME

# By using a here-document to include the source of the perl script (to
# avoid command line length limits), we usurp the normal stdin the inferior
# process might have expected.  So dup stdin onto fd 9, and before the
# inferior process is started, it will be reduped back onto fd 0.
exec $perl $debug $includes - ${1+"$@"} 9<&0 <<'__EOF__'

&main;

sub main
{
  $progname = $ENV{TCPCONNECT_PROGNAME};
  $0 = "$progname ($0)";

  # See comments preceding perl invocation for an explanation.
  if (! open (STDIN, "<&9"))
    {
      &errmsg ("cannot recover stdin from fd 9", "$!");
      exit (1);
    }
  close (9);

  $saved_stty_settings = '';
  if ($ENV{'TCPCONNECT_STTY'} ne "")
    {
      $saved_stty_settings = `stty -g`;
      `stty $ENV{'TCPCONNECT_STTY'}`;

      $SIG{'HUP'}  = 'restore_stty';
      $SIG{'INT'}  = $SIG{'HUP'};
      $SIG{'QUIT'} = $SIG{'HUP'};
      $SIG{'TERM'} = $SIG{'HUP'};
    }

  &initialize_sockvars;
  &tcpconnect (@ARGV);
}

# Args: host, port
sub tcpconnect
{
  local ($rhostname, $port) = @_;
  local ($proto, $name, $aliases, $type, $len, $thisaddr, $rhostaddr);
  local ($in, $out);
  # This is made global so that do_shutdown can use it.
  #local ($child);

  $0 = "$progname ($rhostname:$port)";

  $hostname = `hostname`;
  chop $hostname;

  ($name, $aliases, $proto) = getprotobyname ("tcp");

  if ($port !~ /^\d+$/)
    {
      ($name, $aliases, $port) = getservbyname ($port, "tcp");
    }

  ($name, $aliases, $type, $len, $thisaddr) = gethostbyname ($hostname);

  if ($rhostname =~ /^[0-9.][0-9.]*$/)
    {
      local (@octet) = split (/[.]/, $rhostname);
      @rhostaddr = (pack ('C4', @octet));
      $canon_rhostname = &my_gethostbyaddr ($rhostname, $rhostaddr[0], $type);
    }
  else
    {
      ($name, $aliases, $type, $len, @rhostaddr) = gethostbyname ($rhostname);
      if ($name eq "")
        {
          print (STDERR "$progname: cannot resolve $rhostname\n");
          exit (1);
        }
      $canon_rhostname = $name;
    }

  # Do not use Socket::sockaddr_in even if available, since it does not
  # work for sparc-sun-solaris2.4.  In particular, the pack structure it
  # uses is "S n C4 x8", which is wrong.
  $sockaddr = "S n a4 x8";
  $thishost = pack ($sockaddr, &AF_INET, 0, $thisaddr);

  $ok = 0;
  while ($ok == 0 && $#rhostaddr > -1)
    {
      $rhost = pack ($sockaddr, &AF_INET, $port, $rhostaddr[0]);
      close (S);

      # Make socket filehandle.
      socket (S, &AF_INET, &SOCK_STREAM, $proto)
        || die ("$progname: socket: $!");

      # Give the socket an address.
      bind (S, $thishost)
        || die ("$progname: bind: $!");

      if ("$canon_rhostname" =~ /^[0-9.]+$/)
        {
          $hinfo = "$canon_rhostname port $port";
        }
      else
        {
          $hinfo = "$canon_rhostname ["
                     . &ipaddr2string ($rhostaddr[0])
                     . "] port $port";
        }

      # Connect to server.
      &verbose ("trying $hinfo...");
      if (! connect (S, $rhost))
        {
          &errmsg ("connect", $hinfo, "$!");

          shift (@rhostaddr);
          if ($#rhostaddr >= 0)
            {
              next;
            }
          else
            {
              exit (1);
            }
        }
      else
        {
          &verbose ($hinfo, "connection established.");
          $ok = 1;
        }
    }

  # This is not done until now so that the program is interruptible until
  # the conection is established.
  if ("$ENV{TCPCONNECT_SIGINT}" eq 'nil')
    {
      $SIG{'INT'} = 'IGNORE';
    }

  # Set file handles to be command buffered.
  # Since we do unbuffered sysreads and syswrites this may actually be
  # unnecessary.
  select (S);      $| = 1;
  select (STDIN);  $| = 1;
  select (STDOUT); $| = 1;

  # Avoid deadlock by forking.
  $child = fork ();

  if ($child == 0)
    {
      $SIG{'HUP'} = 'shutdown_child';
      $0 = "$0 [PPID=" . getppid() . "]";
      ($in, $out) = (STDIN, S);
    }
  else
    {
      $SIG{'HUP'} = 'shutdown_parent';
      $SIG{'CHLD'} = 'parent_SIGCHLD_handler';
      ($in, $out) = (S, STDOUT);
    }

  # If sighup may be sent, give time for both processes to finish setting
  # up sig handlers.  This is usually only bcritical if sending input from a
  # pipeline.  Users are slow as paste.
  if ("$ENV{TCPCONNECT_SIGHUP}" ne "nil")
    {
      sleep (1);
    }

  local ($fn) = $SIG{'HUP'};

  while ($len = sysread ($in, $_, 16384))
    {
      syswrite ($out, $_, $len);
    }

  &$fn;
}

# Called by child
sub shutdown_child
{
  # Disable further hup signals
  $SIG{'HUP'} = 'IGNORE';

  local ($ppid) = getppid ();

  if ($ppid != 1 && $ENV{'TCPCONNECT_SIGHUP'} eq "nil")
    {
      shutdown (S, $SHUTDOWN_SEND);
    }
  else
    {
      shutdown (S, $SHUTDOWN_SEND);
      kill ('HUP', $ppid);
    }

  exit (0);
}

# Called by parent
sub shutdown_parent
{
  # Disable further hup signals
  $SIG{'HUP'} = 'IGNORE';

  shutdown (S, $SHUTDOWN_RECEIVE);
  close (S);
  &verbose ($hinfo, "connection closed.");
  &restore_stty;
  if ($ENV{'TCPCONNECT_SIGHUP'} ne "nil")
    {
      kill ('HUP', $child);
    }
  exit (0);
}

# This just reaps the child
sub parent_SIGCHLD_handler
{
  wait;
}

sub restore_stty
{
  if ("$saved_stty_settings" ne '')
    {
      `stty "$saved_stty_settings"`;
    }
}

sub initialize_sockvars
{
  # Args to shutdown.
  $SHUTDOWN_RECEIVE = 0;
  $SHUTDOWN_SEND    = 1;
  $SHUTDOWN_BOTH    = 2;

  if ( int ($]) <= 4 || $ENV{'TCPCONNECT_DYNLOAD'} eq "nil" )
    {
      # Push some include dirs which are pretty standard, just in case.
      # Perl5 does not usually install .ph files.
      push (@INC, "$ENV{HOME}/lib/perl",
                  "/usr/local/gnu/lib/perl",
                  "/usr/local/lib/perl",
                  "/usr/lib/perl"
           );

      if (! &require_soft ("sys/socket.ph"))
        {
          # Backdown if socket.ph cannot be found.
          # These are probably correct, but not guaranteed to be.
          # For example, on sparc-sun-solaris2.4, SOCK_STREAM is 2, not 1.
          sub AF_INET     { return 2; }
          sub SOCK_STREAM { return 1; }
        }
    }
  else
    {
      eval "use Socket;";
    }
}

sub require_soft
{
  local ($f) = @_;

  foreach $dir (@INC)
    {
      if (-f "$dir/$f")
        {
          require "$f";
          return "$dir";
        }
    }
  return 0;
}

sub my_gethostbyaddr
{
  local ($addrstring, $addr, $type) = @_;
  local ($name) = "";

  if ("$ENV{TCPCONNECT_REVRES}" ne "nil")
    {
      $name = gethostbyaddr($addr, $type);
    }

  if ($name eq "")
    {
      return $addrstring;
    }
  return $name;
}

sub ipaddr2string
{
  return sprintf ("%d.%d.%d.%d", unpack ("C4", $_[0]));
}

sub errmsg
{
  printf (STDERR join(": ", $progname, @_) . "\n");
}

sub verbose
{
  if ("$ENV{TCPCONNECT_VERBOSE}" eq "t")
    {
      printf (STDERR join(": ", $progname, @_) . "\n");
    }
}

__EOF__

# tcpconnect ends here.
