#!/bin/sh
# biffjr --- beep and notify when you have new mail
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1993-09-21
# Public domain

# $Id$

# Commentary:

# This script works without the `comsat' daemon, which is not always
# enabled or is buggy (some versions don't work if your username is 8
# characters long).
#
# This program will background itself automatically; you don't need to use
# `&' in the shell.  It terminate itself when you log out.
#
# Because of the means biffjr uses to determine when you've logged out, you
# must be connected to a pty which is owned by you.  Sometimes this is not
# the case in emacs shell buffers.
#
# The --foreground and --ignore-tty-owner options frob this behavior.


# Code:

progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

bq='`'
eq="'"

usage="Usage: $progname {options}

Options are:
-D, --debug                  Turn on shell debugging ($bq${bq}set -x$eq$eq).
-f, --from           FPROG   Display envelopes from new messages.  Optional
                             argument FPROG is the name of the ${bq}from$eq
                             program to execute.
                             This option should either be listed last or
                             the token $bq--from=$eq should be used if the
                             optional argument is not to be supplied.
-F, --foreground             Don't background this program.
                             This option implies $bq--ignore-tty-owner$eq.
-h, --help                   You're looking at it.
-i, --ignore-tty-owner       Do not examine ownership of tty to decide
                             whether to terminate.  
                             Use of this option alone is discouraged
                             because failure to kill this program at logout
                             will annoy the next user to log in.
                             Run this program in the shell foreground
                             instead, using $bq--foreground$eq.
-m, --mail-file      MFILE   Path of mail spool file.
-n, --no-bell                Do not beep when displaying messages.
                             Primarily intended for emacs shell buffers.
-s, --sleep-interval SEC     Interval (in seconds) between mail checks.
                             Default is 60 seconds.
"

# Clever way to save arguments whilst preserving quoting.
# Note that only one set of args can be saved at a time.
# Usage: eval "$save_current_args"
#        eval "$restore_saved_args"
save_current_args='
  {
    _saved_args=
    while : ; do
      case $# in 0 ) break ;; esac
      eval _saved_args$#=\$1
      _saved_args="$_saved_args \"\$_saved_args$#\""
      shift
    done
    eval "$restore_saved_args"
  }'
restore_saved_args='
  {
    eval '\''{ eval set fnord $_saved_args ; }'\''
    shift 
  }'

# Usage: value=`(set - "$1" "$2"; eval "$get_option_argument")`
#
# Long option syntax is `--foo=bar' or `--foo bar'.  2nd argument ARG
# won't get used if first long option syntax was used. 
# If 3rd argument OPTIONAL is set, then 2nd may be empty without resulting
# in an error (i.e. option argument is optional)
#
# Returns number of positions caller should shift.
# If retval = 3, caller should exit.
get_option_argument='
  {
    option="$1" arg="$2" arg_optional="$3" shift_num=2
    case "$option" in
      --*=* )
        arg=`echo $option | sed -e "s/^[^=]*=//"` 
        shift_num=1
       ;;
    esac
    case "$arg" in
      "" )
        case "$arg_optional" in
          "" )
            case "$option" in 
              --*=* ) option=`echo $option | sed -e "s/=.*//"` ;;
            esac
            echo "$progname: option $bq$option$eq requires argument." 1>&2
            echo "$usage" 1>&2
            exit 3
           ;;
        esac
        exit 1
       ;;  
    esac
    echo "$arg"
    exit $shift_num
  }'

# Some bourne shells don't allow a numeric argument to `shift'.
# Usage: eval "shift_num=n; $shift_n_times"
shift_n_times='
  {
    while : ; do
      case "$shift_num" in 0 | "" ) break ;; esac
      shift_num=`expr $shift_num - 1`
      shift
    done
  }'

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
bells=t
debug=
daemonp=f
ignoretty=
mail_file=${MAIL-$MAILPATH}
show_from=
sleep_interval=60

eval "$save_current_args"

# Parse command line arguments. 
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character. 
while test $# != 0 ; do
  case "$1" in 
    # The --daemon option is used by this program when it recursively calls
    # itself in the background, but is not advertised to the user.
    # The --foreground option has mostly the same effect, but it also turns
    # off tty checking since it's not important in that case.
    --daemon )
      daemonp=t
      shift
     ;;
    -D | --debug | --de* )
      debug=t
      shift
     ;;
    -f | --from* | --fr* )
      show_from=`(set - "$1" "$2" arg-optional; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"

      case "$show_from" in
        '' ) : ;;
        * )  FROM=$show_from ;;
      esac
      show_from=t
     ;;
    -F | --foreground | --fo* )
      daemonp=t
      ignoretty=t
      shift
     ;;
    -h | --help | --h )
      echo "$usage" 1>&2
      exit 1
     ;;
    -i | --ignore-tty-owner | --i* )
      ignoretty=t
      shift
     ;;
    -m | --mail-file* | --m* )
      mail_file=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -n | --no-bell | --n* )
      bells=
      shift
     ;;
    -s | --sleep-interval* | --s* )
      sleep_interval=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    --*=* )
      arg=`echo $1 | sed -e 's/=.*//'`
      echo "$progname: unknown option $bq$arg$eq" 1>&2
      echo "$usage" 1>&2
      exit 1
     ;;
    -* )
      echo "$progname: unknown option $bq$1$eq" 1>&2
      echo "$usage" 1>&2
      exit 1
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in t ) set -x ;; esac

case "$ignoretty" in
  t ) : ;;
  * )
    TTY=${TTY-`tty 2> /dev/null`}
    case "$TTY" in
      /dev/* ) : ;;
      * )
        echo "$progname: Can't run without a tty." 1>&2
        exit 1
       ;;
    esac

    USER=${USER-${LOGNAME-`{ id | sed -ne 's/.*uid=[0-9]*(//
                                           s/).*//
                                           p'
                           } \
                           || { (whoami) 2> /dev/null; }`}}
    export TTY USER

    tty_sed='s/	/ /g
             s/^[^ ]* *[0-9]* *//
             s/ .*//
             p'
    tty_owner=`ls -ld "$TTY" | sed -ne "$tty_sed"`
    case "$tty_owner" in 
      "$USER" ) : ;;
      * )
        exec 1>&2
        echo "$progname: You must own $TTY to run this script, or use $bq--foreground$eq"
        ls -ld "$TTY"
        exit 1
       ;;
    esac
   ;;
esac

case "$daemonp" in f )
  eval "$restore_saved_args"
  $0 --daemon ${1+"$@"} &
  echo "$progname backgrounded."
  exit 0
 ;;
esac

case "$mail_file" in '' )
  USER=${USER-${LOGNAME-`{ id | sed -ne 's/.*uid=[0-9]*(//
                                         s/).*//
                                         p'
                         } \
                         || { (whoami) 2> /dev/null; }`}}


  for dir in /usr/spool/mail /var/mail /var/spool/mail /usr/mail ; do
    if test -d "$dir" ; then
      mail_file="$dir/$USER"
      break
    fi
  done
 ;;
esac
case "$bells" in t )
  bells=`echo ..... | tr '.' '\007'` ;;
esac

msgcount='NAN'
msgprefix="$bells*** $progname"

oldstate=

while : ; do
  case "$ignoretty" in
    t ) : ;;
    * )
      tty_owner=`ls -ld "$TTY" | sed -ne "$tty_sed"`
      case "$tty_owner" in 
        "$USER" ) : ;;
        * )
          exit 0 
         ;;
      esac
     ;;
  esac

  if test -s "$mail_file"; then
    state=`ls -ld "$mail_file" 2> /dev/null`
    case "$state" in
      "$oldstate" ) : ;;
      * )
        oldstate="$state"

        case "$show_from" in 
          t )
            echo "$msgprefix: You have new mail."
            echo "$msgprefix: Spooled messages as of `date`:"
            ${FROM-from}
           ;;
          * )
            set fnord `grep '^From ' "$mail_file" 2> /dev/null | wc -l`
            shift
            msgcount=${1-new}

            echo "$msgprefix: You have $msgcount messages as of `date`"
        esac
       ;;
    esac
  fi

  # If sleep exits abnormally, it's probably because of an invalid
  # argument to sleep, in which case no sleep is happening and this script
  # will chew cycles.  So exit instead.
  sleep "$sleep_interval" || exit 1
done

# biffjr ends here
