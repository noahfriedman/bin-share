#!/usr/bin/env python
# pystty --- pure python implementation of stty command

# Author: Noah Friedman <friedman@splode.com>
# Created: 2018-10-30
# Public domain

# Commentary:

# stuff to do:
# 	* grab console: TIOCCONS
#	* document all the supported flags

# Code:

from   __future__ import print_function

import os
import sys
import fcntl
import termios
import struct
import argparse
import re
import time
import functools

OS = os.uname()[0]

# flip bit 7 of c; thus CTRL('C')==3, but CTRL('?')==127
def CTRL(c): return ord( c.upper() ) ^ 0b01000000

# This just generates global variables; there are no objects.
class _Enum():
    @classmethod
    def __init__( self, *args ):
        glbl = globals()
        for n, name in enumerate( args ):
            glbl[ name ] = n

# Singleton wrapper around termios module to handle differences between
# operating systems, including potentially known but undefined attributes.
# Prefer the module attributes if they exist, otherwise try ours, or return
# False as a last resort. False means the attribute is not available,
# whereas None means there may just be no default.
class PseudoTermios( object ):
    @classmethod
    def __dir__( self ):
        d = dict( vars( self ))
        # Merge in the members of termios with our own,
        # since that represents the complete namespace.
        d.update( vars( termios ))
        # And sort them, because dir(x) is usally sorted.
        return sorted( d.keys() )

    @classmethod
    def __getattribute__( self, attr ):
        return getattr( termios, attr, getattr( self, attr, False ))

    # Assigned at class definition time.
    if OS == 'Linux':
        # n.b linux doesn't implement ispeed; ospeed sets both
        B500000    = termios.CBAUDEX | 0o05
        B576000    = termios.CBAUDEX | 0o06
        B921600    = termios.CBAUDEX | 0o07
        B1000000   = termios.CBAUDEX | 0o10
        B1152000   = termios.CBAUDEX | 0o11
        B1500000   = termios.CBAUDEX | 0o12
        B2000000   = termios.CBAUDEX | 0o13
        B2500000   = termios.CBAUDEX | 0o14
        B3000000   = termios.CBAUDEX | 0o15
        B3500000   = termios.CBAUDEX | 0o16
        B4000000   = termios.CBAUDEX | 0o17

        CMSPAR     = 0o10000000000
        EXTPROC    =      0o200000
        IUTF8      =       0o40000

        # Termux (android) python doesn't define these.
        CINTR      = CTRL( 'C' )
        CQUIT      = CTRL( '\\' )
        CERASE     = CTRL( '?' )
        CERASE2    = CTRL( 'H' )
        CKILL      = CTRL( 'U' )
        CEOF       = CTRL( 'D' )
        CEOL       = CTRL( '@' ) # PC_VDISABLE
        CSTART     = CTRL( 'Q' )
        CSTOP      = CTRL( 'S' )
        CSUSP      = CTRL( 'Z' )
        CDSUSP     = CTRL( 'Y' )
        CRPRNT     = CTRL( 'R' )
        CSTATUS    = CTRL( 'T' )
        CWERASE    = CTRL( 'W' )
        CLNEXT     = CTRL( 'V' )
        CFLUSH     = CTRL( 'O' )

        # Some line disciplines which python doesn't usually define.
        N_AX25     =  5
        N_X25      =  6 # X.25 async
        N_IRDA     = 11 # http://irda.sourceforge.net/
        N_SMSBLOCK = 12 # SMS block mode for GSM
        N_SYNC_PPP = 14 # synchronous PPP
        N_HCI      = 15 # Bluetooth HCI UART
        N_SLCAN    = 17 # Serial / USB serial CAN Adaptors
        N_PPS      = 18 # Pulse per Second (GPS, etc)
        N_NULL     = 27 # Null ldisc used for error handling

    elif OS == 'FreeBSD':
        # Unlike linux, the freebsd speeds are pretty direct.
        B7200      =   7200
        B14400     =  14400
        B28800     =  28800
        B57600     =  57600
        B76800     =  76800
        B115200    = 115200
        B230400    = 230400
        B460800    = 460800
        B921600    = 921600

        VERASE2    =  7
        VDSUSP     = 11
        VSTATUS    = 18

        CERASE2    = CTRL( 'H' )
        CDSUSP     = CTRL( 'Y' )
        CSTATUS    = CTRL( 'T' )

        # lflags: nokerninfo altwerase extproc
        NOKERNINFO = 0x02000000	# no kernel output from VSTATUS
        ALTWERASE  = 0x00000200 # use alternate WERASE algorithm
        EXTPROC    = 0x00000800 # external processing

        # cflags: dsrflow dtrflow mdmbuf
        CCTS_OFLOW = 0x00010000	# CTS flowctl of output
        CRTS_IFLOW = 0x00020000	# RTS flowctl of input
        CDTR_IFLOW = 0x00040000	# DTR flowctl of input
        CDSR_OFLOW = 0x00080000	# DSR flowctl of output
        CCAR_OFLOW = 0x00100000	# DCD flowctl of output

        # Line disciplines from sys/ttycom.h
        # The actual macros don't start with `N_' and *do* end with `DISC'.
        N_TTY      =  0 # TTYDISC      - termios tty
        N_SLIP     =  4 # SLIPDISC     - serial IP
        N_PPP      =  5 # PPPDISC      - PPP
        N_NETGRAPH =  6 # NETGRAPHDISC - Netgraph tty node
        N_H4       =  7 # H4DISC       - Netgraph Bluetooth H4

_termios = _t = PseudoTermios()

POSIX = True

_Enum( 'TC_IFLAG',	# tc*etattr fields, and values in FLL_XFLAG/FL_XFLAG slots
       'TC_OFLAG',
       'TC_CFLAG',
       'TC_LFLAG',
       'TC_ISPEED',
       'TC_OSPEED',
       'TC_CC', )

FLAG_LABEL = { TC_IFLAG  : 'iflags',
               TC_OFLAG  : 'oflags',
               TC_CFLAG  : 'cflags',
               TC_LFLAG  : 'lflags',
               TC_ISPEED : 'ispeed',
               TC_OSPEED : 'ospeed',
               TC_CC     : 'cchars', }
# Add inverse of the above
FLAG_LABEL.update( { v : k for k, v in FLAG_LABEL.items() } )


_Enum( 'FLL_NAME',	# fields in FLAG_LIST
       'FLL_XFLAG',
       'FLL_FIELD',
       'FLL_FIELD_VALUE',
       'FLL_SANE_SETTING',
       'FLL_POSIX',
       'FLL_HELP', )

# This table is ordered the same as their numeric bit values on Linux,
# and by ancestral heredity is mostly the same on other platforms too.
# They are displayed in *this* order regardless.
# (Some native versions of stty have a different order that doesn't match
# either this or their native bit order.)
FLAG_LIST = (
    ( 'ignbrk',     TC_IFLAG,  termios.IGNBRK,     None,     False, POSIX, 'ignore break chars' ),
    ( 'brkint',     TC_IFLAG,  termios.BRKINT,     None,     True,  POSIX, 'breaks cause an interrupt signal' ),
    ( 'ignpar',     TC_IFLAG,  termios.IGNPAR,     None,     None,  POSIX, 'ignore chars with parity errors' ),
    ( 'parmrk',     TC_IFLAG,  termios.PARMRK,     None,     None,  POSIX, 'mark parity errors with a 255-0-char sequence' ),
    ( 'inpck',      TC_IFLAG,  termios.INPCK,      None,     None,  POSIX, 'enable input parity checking' ),
    ( 'istrip',     TC_IFLAG,  termios.ISTRIP,     None,     None,  POSIX, 'clear 8th bit of input chars' ),
    ( 'inlcr',      TC_IFLAG,  termios.INLCR,      None,     False, POSIX, 'xlate newline to carriage return' ),
    ( 'igncr',      TC_IFLAG,  termios.IGNCR,      None,     False, POSIX, 'ignore carriage return' ),
    ( 'icrnl',      TC_IFLAG,  termios.ICRNL,      None,     True,  POSIX, 'xlate carriage return to newline' ),
    ( 'iuclc',      TC_IFLAG, _termios.IUCLC,      None,     False, False, 'xlate uppercase chars to lowercase' ),
    ( 'ixon',       TC_IFLAG,  termios.IXON,       None,     None,  POSIX, 'enable xon/xoff flow control'),
    ( 'ixany',      TC_IFLAG, _termios.IXANY,      None,     False, False, 'any char restarts output, not only start char' ),
    ( 'ixoff',      TC_IFLAG,  termios.IXOFF,      None,     False, POSIX, 'enable sending start/stop chars' ),
    ( 'imaxbel',    TC_IFLAG, _termios.IMAXBEL,    None,     True,  False, 'beep and do not flush a full input buffer on a character' ),
    ( 'iutf8',      TC_IFLAG, _termios.IUTF8,      None,     False, False, 'assume input chars are UTF-8 encoded' ),

    ( 'opost',      TC_OFLAG,  termios.OPOST,      None,     True,  POSIX, 'postprocess output' ),
    ( 'olcuc',      TC_OFLAG, _termios.OLCUC,      None,     False, False, 'xlate lowercase chars to uppercase' ),
    ( 'onlcr',      TC_OFLAG, _termios.ONLCR,      None,     True,  False, 'xlate newline to carriage return-newline' ),
    ( 'ocrnl',      TC_OFLAG, _termios.OCRNL,      None,     False, False, 'xlate carriage return to newline' ),
    ( 'onocr',      TC_OFLAG, _termios.ONOCR,      None,     False, False, 'do not print carriage returns in 1st column' ),
    ( 'onlret',     TC_OFLAG, _termios.ONLRET,     None,     False, False, 'newline performs a carriage return'),
    ( 'ofill',      TC_OFLAG, _termios.OFILL,      None,     False, False, 'use fill (padding) chars instead of timing for delays' ),
    ( 'ofdel',      TC_OFLAG, _termios.OFDEL,      None,     False, False, 'use DEL chars for fill instead of NUL' ),
    ( 'nl0',        TC_OFLAG, _termios.NLDLY,      _t.NL0,   True,  'nlN', 'newline delay style, N in [0..1]' ),
    ( 'nl1',        TC_OFLAG, _termios.NLDLY,      _t.NL1,   None,  False, None ),
    ( 'cr0',        TC_OFLAG, _termios.CRDLY,      _t.CR0,   True,  'crN', 'carriage return delay style, N in [0..3]' ),
    ( 'cr1',        TC_OFLAG, _termios.CRDLY,      _t.CR1,   None,  False, None ),
    ( 'cr2',        TC_OFLAG, _termios.CRDLY,      _t.CR2,   None,  False, None ),
    ( 'cr3',        TC_OFLAG, _termios.CRDLY,      _t.CR3,   None,  False, None ),
    ( 'tab0',       TC_OFLAG, _termios.TABDLY,     _t.TAB0,  True,  'tabN', 'horizontal tab delay style, N in [0..3]' ),
    ( 'tab1',       TC_OFLAG, _termios.TABDLY,     _t.TAB1,  None,  False, None ),
    ( 'tab2',       TC_OFLAG, _termios.TABDLY,     _t.TAB2,  None,  False, None ),
    ( 'tab3',       TC_OFLAG, _termios.TABDLY,     _t.TAB3,  None,  False, 'expand tabs to spaces' ),
    ( 'xtabs',      TC_OFLAG, _termios.TABDLY,     _t.XTABS, None,  False, None ),
    ( 'bs0',        TC_OFLAG, _termios.BSDLY,      _t.BS0,   True,  'bsN', 'backspace delay style, N in [0..1]' ), # linux: not impl
    ( 'bs1',        TC_OFLAG, _termios.BSDLY,      _t.BS1,   None,  False, None ),
    ( 'vt0',        TC_OFLAG, _termios.VTDLY,      _t.VT0,   True,  'vtN', 'vertical tab delay style, N in [0..1]' ),
    ( 'vt1',        TC_OFLAG, _termios.VTDLY,      _t.VT1,   None,  False, None ),
    ( 'ff0',        TC_OFLAG, _termios.FFDLY,      _t.FF0,   True,  'ffN', 'form feed delay style, N in [0..1]' ),
    ( 'ff1',        TC_OFLAG, _termios.FFDLY,      _t.FF1,   None,  False, None ),

    ( 'cs5',        TC_CFLAG, _termios.CSIZE,      _t.CS5,   None,  'crN', 'carriage return delay style, N in [0..3]' ),
    ( 'cs6',        TC_CFLAG, _termios.CSIZE,      _t.CS6,   None,  False, None ),
    ( 'cs7',        TC_CFLAG, _termios.CSIZE,      _t.CS7,   None,  False, None ),
    ( 'cs8',        TC_CFLAG, _termios.CSIZE,      _t.CS8,   None,  False, None ),
    ( 'cstopb',     TC_CFLAG,  termios.CSTOPB,     None,     None,  POSIX, "use 2 stop bits per char (1 with '-')" ),
    ( 'cread',      TC_CFLAG,  termios.CREAD,      None,     True,  POSIX, 'allow input to be received' ),
    ( 'parenb',     TC_CFLAG,  termios.PARENB,     None,     None,  POSIX, 'generate parity bit in output and expect parity bit in input' ),
    ( 'parodd',     TC_CFLAG,  termios.PARODD,     None,     None,  POSIX, "set odd parity (or even parity with '-')" ),
    ( 'hupcl',      TC_CFLAG,  termios.HUPCL,      None,     None,  POSIX, 'send hangup signal when last process closes tty' ),
    ( 'clocal',     TC_CFLAG,  termios.CLOCAL,     None,     None,  POSIX, 'disable modem control signals' ),
    ( 'cmspar',     TC_CFLAG, _termios.CMSPAR,     None,     None,  False, 'use "stick" (mark/space) parity' ),
    ( 'crtscts',    TC_CFLAG, _termios.CRTSCTS,    None,     None,  False, 'enable RTS/CTS handshaking' ),
    ( 'cdtrcts',    TC_CFLAG, _termios.CDTRCTS,    None,     None,  False, 'enable DTR/CTS handshaking' ),           # netbsd
    ( 'loblk',      TC_CFLAG, _termios.LOBLK,      None,     None,  False, 'block output from non-current layers' ), # solaris
    ( 'dtrflow',    TC_CFLAG, _termios.CDTR_IFLOW, None,     None,  False, 'start/stop input on DTR' ),              # freebsd
    ( 'dsrflow',    TC_CFLAG, _termios.CDSR_OFLOW, None,     None,  False, 'start/stop output on DSR' ),             # freebsd
    ( 'mdmbuf',     TC_CFLAG, _termios.CCAR_OFLOW, None,     None,  False, 'start/stop on carrier' ),                # bsd

    ( 'isig',       TC_LFLAG,  termios.ISIG,       None,     True,  POSIX, 'enable interrupt, quit, and suspend special chars' ),
    ( 'icanon',     TC_LFLAG,  termios.ICANON,     None,     True,  POSIX, 'enable special chars: erase, kill, werase, rprnt' ),
    ( 'xcase',      TC_LFLAG, _termios.XCASE,      None,     False, False, "with icanon, escape with '\x5c' for uppercase chars" ),
    ( 'echo',       TC_LFLAG,  termios.ECHO,       None,     True,  POSIX, 'echo input chars' ),
    ( 'echoe',      TC_LFLAG,  termios.ECHOE,      None,     True,  POSIX, 'echo erase chars as backspace-space-backspace' ),
    ( 'echok',      TC_LFLAG,  termios.ECHOK,      None,     True,  POSIX, 'echo a newline after a kill char' ),
    ( 'echonl',     TC_LFLAG,  termios.ECHONL,     None,     False, POSIX, 'echo newline even if not echoing other chars' ),
    ( 'noflsh',     TC_LFLAG,  termios.NOFLSH,     None,     False, POSIX, 'disable flushing after interrupt and quit special chars' ),
    ( 'tostop',     TC_LFLAG,  termios.TOSTOP,     None,     False, POSIX, 'stop background jobs that try to write to the terminal' ),
    ( 'echoctl',    TC_LFLAG, _termios.ECHOCTL,    None,     True,  False, "echo control chars in '^c' notation" ),
    ( 'echoprt',    TC_LFLAG, _termios.ECHOPRT,    None,     False, False, "echo erased chars backward, between '\x5c' and '/'" ),
    ( 'echoke',     TC_LFLAG, _termios.ECHOKE,     None,     True,  False, "kill line by obeying the echoprt ('-' echoctl) and echoe ('-' echok) settings" ),
    ( 'flusho',     TC_LFLAG, _termios.FLUSHO,     None,     False, False, 'discard output' ),
    ( 'pendin',     TC_LFLAG, _termios.PENDIN,     None,     None,  False, 'retype pending input' ),
    ( 'iexten',     TC_LFLAG,  termios.IEXTEN,     None,     True,  POSIX, 'enable non-POSIX special chars' ),
    ( 'extproc',    TC_LFLAG, _termios.EXTPROC,    None,     False, False, 'enable "line mode"; useful with high latency links' ),
    ( 'defecho',    TC_LFLAG, _termios.DEFECHO,    None,     None,  False, 'echo only when a process is reading' ),          # solaris
    ( 'altwerase',  TC_LFLAG, _termios.ALTWERASE,  None,     None,  False, 'Use alternate word erase algorithm' ),           # bsd
    ( 'nokerninfo', TC_LFLAG, _termios.NOKERNINFO, None,     None,  False, 'Enable status line when STATUS char detected' ), # bsd
)
# If you really wanted to sort the output, you could do so here.
# Some sort key options: FLL_NAME for alphabetic, FLL_FIELD for bit order
#FLAG_LIST = sorted( FLAG_LIST, key=lambda row: row[FLL_NAME] )


_Enum( 'FL_XFLAG',	# fields in FLAG
       'FL_FIELD',
       'FL_FIELD_VALUE',
       'FL_SANE_SETTING',
       'FL_POSIX',
       'FL_HELP', )

FLAG = { elt[ 0 ] : elt[ 1: ] for elt in FLAG_LIST }

SPEED = { k[1:] : getattr( _termios, k )
          for k in dir( _termios )
          if k[0] == 'B' and k[1] in '0123456789' }
NTOSPEED = { v : k for k, v in SPEED.items() }

_Enum( 'CC_PARAM_LIST_NAME',
       'CC_PARAM_LIST_POS',
       'CC_PARAM_LIST_DFLT', )

CC_PARAM_LIST = (
    ('intr',     termios.VINTR,    _termios.CINTR,   ), # ^C
    ('quit',     termios.VQUIT,    _termios.CQUIT,   ), # ^\
    ('erase',    termios.VERASE,   _termios.CERASE,  ), # ^?
    ('erase2',  _termios.VERASE2,  _termios.CERASE2, ), # ^H
    ('kill',     termios.VKILL,    _termios.CKILL,   ), # ^U
    ('eof',      termios.VEOF,     _termios.CEOF,    ), # ^D
    ('eol',      termios.VEOL,     _termios.CEOL,    ), # ^@
    ('eol2',     termios.VEOL2,     None,            ),
    ('swtch',   _termios.VSWTCH,    None,            ),
    ('start',    termios.VSTART,   _termios.CSTART,  ), # ^Q
    ('stop',     termios.VSTOP,    _termios.CSTOP,   ), # ^S
    ('susp',     termios.VSUSP,    _termios.CSUSP,   ), # ^Z
    ('dsusp',   _termios.VDSUSP,   _termios.CDSUSP,  ), # ^Y
    ('rprint',   termios.VREPRINT, _termios.CRPRNT,  ), # ^R
    ('werase',   termios.VWERASE,  _termios.CWERASE, ), # ^W
    ('lnext',    termios.VLNEXT,   _termios.CLNEXT,  ), # ^V
    ('discard',  termios.VDISCARD, _termios.CFLUSH,  ), # ^O
    ('status',  _termios.VSTATUS,  _termios.CSTATUS, ), # ^T
    ('min',      termios.VMIN,      1,               ),
    ('time',     termios.VTIME,     0,               ), )

# Would sorting these alphabetically be easier to read?
#CC_PARAM_LIST = sorted( CC_PARAM_LIST, key=lambda k: k[0] )

_Enum( 'CC_PARAM_POS',
       'CC_PARAM_DFLT', )

CC_PARAM = { elt[ 0 ] : elt[ 1: ] for elt in CC_PARAM_LIST }
CC_PARAM[ 'swtc' ] = CC_PARAM[ 'swtch' ]

STDKEYS = []
for elt in CC_PARAM_LIST:
    if (     elt[1] is not None
         and elt[1] is not False
         and elt[2] is not None):
        STDKEYS.extend( elt[0:3:2] )

def cc_dflt( name ):
    return CC_PARAM[ name ][ CC_PARAM_DFLT ]

ALIAS = {
     'cbreak'   : [ '-icanon' ],
    '-cbreak'   : [  'icanon' ],

     'cooked'   : [  'brkint',
                     'ignpar',
                     'istrip',
                     'icrnl',
                     'ixon',
                     'opost',
                     'isig',
                     'icanon',
                     'eof',    cc_dflt( 'eof' ),
                     'eol',    cc_dflt( 'eol' ), ],

     'crt'      : [  'echoe', 'echoctl', 'echoke' ],

     'crterase' : [  'echoe' ],
    '-crterase' : [ '-echoe' ],

     'crtkill'  : [  'echoke' ],
    '-crtkill'  : [ '-echoke' ],

     'ctlecho'  : [  'echoctl' ],
    '-ctlecho'  : [ '-echoctl' ],

     'dec'      : [  'echoe',
                     'echoctl',
                     'echoke',
                    '-ixany',
                     'intr',   cc_dflt( 'intr'  ),
                     'erase',  cc_dflt( 'erase' ),
                     'kill',   cc_dflt( 'kill'  ), ],

     'decctlq'  : [  'ixany' ],
    '-decctlq'  : [ '-ixany' ],

     'ek'       : [  'erase',  cc_dflt( 'erase' ),
                     'kill',   cc_dflt( 'kill'  ), ],

     'evenp'    : [  'cs7',  'parenb', '-parodd', ],
    '-evenp'    : [  'cs8', '-parenb', ],

      'hup'     : [  'hupcl', ],
     '-hup'     : [ '-hupcl', ],

     'lcase'    : [  'xcase',  'iuclc',  'olcuc', ],
    '-lcase'    : [ '-xcase', '-iuclc', '-olcuc', ],

     'litout'   : [ '-parenb', '-istrip', '-opost', 'cs8', ],
    '-litout'   : [  'parenb'   'istrip'   'opost'  'cs7', ],

     'nl'       : [ '-icrnl', '-onlcr', ],
    '-nl'       : [  'icrnl', '-inlcr', '-igncr',  'onlcr', '-ocrnl', '-onlret', ],

     'oddp'     : [  'cs7',  'parenb',  'parodd', ],
    '-oddp'     : [  'cs8', '-parenb', ],

     'parity'   : [  'evenp' ],
    '-parity'   : [ '-evenp' ],

     'pass8'    : [ '-parenb', '-istrip', 'cs8' ],
    '-pass8'    : [  'parenb',  'istrip', 'cs7' ],

     'prterase' : [ 'echoprt', ],
    '-prterase' : [ '-echoprt', ],

     'raw'      : [ '-ignbrk',
                    '-brkint',
                    '-ignpar',
                    '-parmrk',
                    '-inpck',
                    '-istrip',
                    '-inlcr',
                    '-igncr',
                    '-icrnl',
                    '-ixon',
                    '-ixoff',
                    '-icanon',
                    '-opost',
                    '-isig',
                    '-iuclc',
                    '-ixany',
                    '-imaxbel',
                    '-xcase',
                     'min',    1,
                     'time',   0, ],

     # We ought to be able to compute this one from CC_PARAM_LIST
     'sane'     : [ '-ignbrk',		# iflags
                     'brkint',
                    '-inlcr',
                    '-igncr',
                     'icrnl',
                    '-iuclc',
                    '-ixany',
                    '-ixoff',
                     'imaxbel',
                    '-iutf8',

                     'opost',		# oflags
                    '-olcuc',
                     'onlcr',
                    '-ocrnl',
                    '-onocr',
                    '-onlret',
                    '-ofill',
                    '-ofdel',
                     'nl0',
                     'cr0',
                     'tab0',
                     'bs0',
                     'vt0',
                     'ff0',

                     'cread',		# cflags

                     'isig',		# lflags
                     'icanon',
                    '-xcase',
                     'echo',
                     'echoe',
                     'echok',
                    '-echonl',
                    '-noflsh',
                    '-tostop',
                     'echoctl',
                    '-echoprt',
                     'echoke',
                    '-flusho',
                     'iexten',
                    '-extproc', ], # +STDKEYS below

     'tabs'     : [  'tab0' ],
    '-tabs'     : [  'tab3' ],

     'tandem'   : [  'ixoff' ],
    '-tandem'   : [ '-ixoff' ], }

ALIAS[  'LCASE'  ] = ALIAS[  'lcase'  ]
ALIAS[ '-LCASE'  ] = ALIAS[ '-lcase'  ]
ALIAS[ '-cooked' ] = ALIAS[  'raw'    ]
ALIAS[ '-raw'    ] = ALIAS[  'cooked' ]
ALIAS[  'sane'   ].extend( STDKEYS )

_Enum( 'WS_ROW',	# TIOC*WINSZ fields
       'WS_COL',
       'WS_XPIXEL',
       'WS_YPIXEL', )

termsz_rows = ('rows', 'height')
termsz_cols = ('cols', 'width', 'columns')
termsz_xpix = ('xpixels', 'xpixel', 'xpix' )
termsz_ypix = ('ypixels', 'ypixel', 'ypix' )

TERMSZ = {}
TERMSZ.update( (label, WS_ROW)    for label in termsz_rows )
TERMSZ.update( (label, WS_COL)    for label in termsz_cols )
TERMSZ.update( (label, WS_XPIXEL) for label in termsz_xpix )
TERMSZ.update( (label, WS_YPIXEL) for label in termsz_ypix )


# character used to disable a cchar; usually 0 or 255
try:
    PC_VDISABLE = os.fpathconf( 0, 'PC_VDISABLE' )
except ValueError:
    PC_VDISABLE = 0


def debugtrace_only( fn ):
    def debug_excepthook( exc, val, sta ):
        sys.excepthook = sys.__excepthook__
        debug = os.getenv( 'PYSTTY_DEBUG' ) or '0'
        if debug.lower() not in ('0', 'no', 'off', 'false', 'disable'):
            return sys.__excepthook__( exc, val, sta )
        else:
            tblist = []
            tb = sta
            while tb.tb_next:
                tblist.append( tb )
                tb = tb.tb_next
            fr = tb.tb_frame     # last (innermost) frame
            f_name = fr.f_code.co_name
            if f_name in ('_chkspeed',):
                # skip over wrapper
                f_name = tblist[-2].tb_frame.f_code.co_name
            if issubclass( exc, termios.error ):
                if 'self' in fr.f_locals:
                    args = [ fr.f_locals[ 'self' ].fd_name ]
                    if len( val.args ) > 1:
                        args.extend( val.args[1:] )
                    else:
                        args.extend( val.args )
                else:
                    args = val.args
            else:
                args = list( val.args )
            print( os.path.basename( sys.argv[0] ) or exc.__name__,
                   f_name,
                   *args,
                   sep  = ': ',
                   file = sys.stderr )


    @functools.wraps( fn )
    def wrapper( *args, **kwargs ):
        # Do not use an exception handler to save and restore excepthook;
        # it should only be restored if no exception occurs.
        prior_excepthook = sys.excepthook
        sys.excepthook = debug_excepthook
        result = fn( *args, **kwargs )
        sys.excepthook = prior_excepthook
        return result

    return wrapper

class Stty( object ):
    def __init__( self, fd=sys.stdin, when=termios.TCSANOW ):
        self.open( fd )
        self.when    = when
        self._attr   = None


    @classmethod
    def _byteconv( self, c ):
        'Convert ints to str and then str to bytes (binary str) if necessary.'
        if bytes is str:                 # python2
            if   isinstance( c, int ):   return chr( c )
            else:                        return c
        else:                            # python3
            if   isinstance( c, bytes ): return c
            elif isinstance( c, int ):   return bytes( (c,) )
            else:                        return bytes( ord( x ) for x in c )


    cctrans = None

    @classmethod
    def _cctrans_init( self ):
        if self.cctrans: return
        b = self._byteconv  # for brevity
        cctrans = self.cctrans = {}
        cctrans[ 'C-?' ]  = b( '\x7f' )
        seq = { ''        : b( PC_VDISABLE ),
                'NUL'     : b( '\x00' ),
                'NULL'    : b( '\x00' ),
                'undef'   : b( PC_VDISABLE ),
                '<undef>' : b( PC_VDISABLE ),
                'BS'      : b( '\x08' ),
                'TAB'     : b( '\x09' ),
                'NL'      : b( '\x0a' ),
                'LF'      : b( '\x0a' ),
                'LFD'     : b( '\x0a' ),
                'CR'      : b( '\x0d' ),
                'RET'     : b( '\x0d' ),
                'ESC'     : b( '\x1b' ),
               #'SP'      : b( '\x20' ),
               #'SPC'     : b( '\x20' ),
                'DEL'     : b( '\x7f' ),
                '^?'      : b( '\x7f' ), }
        for s in seq:
            cctrans[ s.upper() ] = seq[ s ]
            cctrans[ s.lower() ] = seq[ s ]
        for c in range( 0, 32 ):
            hi = chr( c | 1<<6 )  # uppercase
            xlate = [ chr( c ), '^'+hi, 'C-'+hi ]
            # after ^Z, don't set bit 5 for lowercase
            if 0 < c < 27:
                lo = chr( c | 3<<5 )
                xlate.extend( ('^'+lo, 'C-'+lo,) )
            char = b( c )
            for s in xlate:
                cctrans[ s ] = char


    @debugtrace_only
    def open( self, _file ):
        if hasattr( _file, 'fileno' ):
            self.fd_name = _file.name
            self.fd      = _file
        else:
            fl = os.O_RDONLY | os.O_NONBLOCK | os.O_NOCTTY
            self.fd_name = _file
            self.fd = os.open( _file, fl)


    @staticmethod
    @debugtrace_only
    def _chkspeed( speed ):
        try:
            sp = SPEED[ speed ] # might be None
        except KeyError:
            sp = None
        if sp is None:
            raise OSError( '"{}": unsupported speed'.format( speed ))
        return sp


    @debugtrace_only
    def tcgetattr( self, reset=False ):
        if reset or self._attr is None:
            self._attr = termios.tcgetattr( self.fd )
        return self._attr


    @debugtrace_only
    def tcsetattr( self, when=termios.TCSANOW ):
        self.tcgetattr()
        return termios.tcsetattr ( self.fd, when, self._attr )


    def Xflag( self, c_elt, flag=None, set=None ):
        self.tcgetattr()
        if flag is None:
            if isinstance( set, int ):
                self._attr[ c_elt ] = set
        elif set is None:
            return self._attr[ c_elt ] & flag
        elif set is True:
            self._attr[ c_elt ] |= flag
        elif set is False:
            self._attr[ c_elt ] &= ~flag
        elif isinstance( set, int ):
            # If set is a number, flag is a mask
            self._attr[ c_elt ] &= ~flag
            self._attr[ c_elt ] |= set
        return self._attr[ c_elt ]


    def sane_default( self, arg ):
        if arg[0] == '-':
            data = FLAG[ arg[1:] ]
        else:
            data = FLAG[ arg ]
        return data[ FL_SANE_SETTING ]


    @debugtrace_only
    def setflag( self, arg ):
        try:
            if arg[0] == '-':
                data = FLAG[ arg[1:] ]
            else:
                data = FLAG[ arg ]
        except KeyError as e:
            e.args = ( arg, 'Invalid or unsupported argument' )
            raise
        if data[ FL_FIELD_VALUE ] is None:
            val = bool( arg[0] != '-' )
        else:
            val = data[ FL_FIELD_VALUE ]
        return self.Xflag( data[ FL_XFLAG ], data[ FL_FIELD ], val )


    def getispeed( self ):
        self.tcgetattr()
        return self._attr[ TC_ISPEED ]


    def setispeed( self, speed ):
        self.tcgetattr()
        self._attr[ TC_ISPEED ] = self._chkspeed( speed )


    def getospeed( self ):
        self.tcgetattr()
        return self.Xflag( TC_OSPEED )


    def setospeed( self, speed ):
        self.tcgetattr()
        self._attr[ TC_OSPEED ] = self._chkspeed( speed )


    def getcc( self, key ):
        self.tcgetattr()
        return self._attr[ TC_CC ][ key ]


    @debugtrace_only
    def setcc( self, key, char ):
        self.tcgetattr()
        if key in [termios.VMIN, termios.VTIME]:
            char = int( char )
        else:
            if isinstance( char, int ):
                char = chr( char )
            self._cctrans_init()
            try:
                char = self.cctrans[ char ]
            except KeyError as err:
                conv_result = intconv( char )
                if conv_result is None:
                    if len( char ) > 1:
                        # KeyError.args will be forced into a tuple,
                        # so we can't modify anything assigned to it.
                        # Some baroque machinations here to accomodate python2.
                        nargs = list( err.args )
                        nargs.append( 'unrecognized character sequence' )
                        err.args = nargs # converted to suple
                        raise
                    else:
                        conv_result = char
                char = self._byteconv( conv_result )
        self._attr[ TC_CC ][ key ] = char
        return char


    @debugtrace_only
    def getwinsz( self, fd=None ):
        raw = fcntl.ioctl ( fd or self.fd, termios.TIOCGWINSZ, '  ' * 4 )
        winsz = list( struct.unpack( '@4H', raw ) )
        if not fd:
            self._winsz = winsz
        return winsz


    @debugtrace_only
    def setwinsz( self, fd=None, winsz=None ):
        if not winsz:
            winsz = self._winsz
        raw = struct.pack( '@4H', *winsz )
        return fcntl.ioctl( fd or self.fd, termios.TIOCSWINSZ, raw )


    @debugtrace_only
    def getldisc( self ):
        try:
            raw = fcntl.ioctl( self.fd, termios.TIOCGETD, '\x00' * 4 )
            self._ldisc = struct.unpack( '@i', raw )[0]
            return self._ldisc
        except (OSError, AttributeError):
            pass # TIOCGETD undefined/unimplemented on cygwin, VMkernel, etc.


    @debugtrace_only
    def setldisc( self, n ):
        try:
            raw = struct.pack( '@i', n )
        except struct.error as err:
            raise OSError( self, 'unknown line discipline "{}"'.format( n ))
        return fcntl.ioctl( self.fd, termios.TIOCSETD, raw )


    def ldisc_name_maps( self ):
        names = list( n for n in dir( _termios ) if n.find( 'N_' ) == 0 )
        formap = { name[2:].lower() : getattr( _termios, name ) for name in names }
        revmap = { v : k for k, v in formap.items() }
        return (formap, revmap)

    # Some platforms have an additional line discipline flag in the termios
    # structure which may be different from that returned by TIOCGETD.
    # `template' is a template string representing the termios C struct.
    # 'TC_LINE' is the index into the unpacked struct of the `c_line' member.
    # See python `struct' class for further details.
    tcgets_param = {
        'Linux'   : { 'template'  : '@4I B {}c 2I'.format( termios.NCCS ),
                      'TC_LINE'   : 4, }, }
    for platform in tcgets_param.values():
        platform[ 'bufsize' ] = struct.calcsize( platform[ 'template' ] )

    # I suspect ESXi supports this to be API-compatible with linux but the
    # c_line field is non-functional, since there are no tty line disciplines
    # on ESXi; in fact using TIOCGETD returns an error.
    tcgets_param[ 'VMkernel' ] = tcgets_param[ 'Linux' ]

    tcsets_when = { termios.TCSANOW   : getattr( termios, 'TCSETS',  None ),
                    termios.TCSADRAIN : getattr( termios, 'TCSETSW', None ),
                    termios.TCSAFLUSH : getattr( termios, 'TCSETSF', None ), }


    @debugtrace_only
    def _tcgets( self, reset=False ):
        try:
            param = self.tcgets_param[ OS ]
            bufsize = param[ 'bufsize' ]
            buf  = fcntl.ioctl( self.fd, termios.TCGETS, '\x00' * bufsize )
            return list( struct.unpack( param[ 'template' ], buf ) )
        except (KeyError, AttributeError):
            pass


    @debugtrace_only
    def _tcsets( self, attr ):
        template = self.tcgets_param[ OS ][ 'template' ]
        raw  = struct.pack( template, *attr )
        when = self.tcsets_when[ self.when ]
        return fcntl.ioctl( self.fd, when, raw )


    def getcline( self ):
        attr = self._tcgets()
        if attr:
            return attr[ self.tcgets_param[ OS ][ 'TC_LINE' ] ]


    @debugtrace_only
    def setcline( self, line ):
        # note: setting the c_line field is permitted, at least on linux,
        # but doing so doesn't change any functional behavior so it's a
        # frivolous thing to do. You have to use setldisc to affect the
        # line discipline, like any other unix system.
        attr = self._tcgets()
        if attr:
            attr[ self.tcgets_param[ OS ][ 'TC_LINE' ] ] = line
            try:
                self._tcsets( attr )
            except struct.error as err:
                raise OSError( self, 'unknown line discipline "{}"'.format( line ))


    def save( self, verbose=False ):
        if verbose:
            return self._save_gpysttyv()
        else:
            return self._save_gpysttyc()


    def _save_gpysttyc( self ):
        g = [ 'gpysttyc' ]
        for n, data in enumerate( self.tcgetattr() ):
            name = FLAG_LABEL[ n ]
            if name in ['cchars']:
                for c in data:
                    try:
                        g.append( '{:x}'.format( ord( c )))
                    except TypeError: # min, time are int already
                        g.append( '{:x}'.format( c ))
            else:
                g.append( '{:x}'.format( data ) )
        return str.join( ':', g )


    def _save_gpysttyv( self ):
        g = [ 'gpysttyv' ]
        for n, data in enumerate( self.tcgetattr() ):
            name = FLAG_LABEL[ n ]
            if n in [ TC_CC ]:
                for elt in CC_PARAM_LIST:
                    cc_pos  = elt[ CC_PARAM_LIST_POS  ]
                    if cc_pos is None or cc_pos is False:
                        continue
                    cc_name = elt[ CC_PARAM_LIST_NAME ]
                    try:
                        cc = ord( data[ cc_pos ] )
                    except TypeError: # min, time are int already
                        cc = data[ cc_pos ]
                    g.append( '{}={:x}'.format( cc_name, cc ))
            elif n in [ TC_ISPEED, TC_OSPEED ]:
                g.append( '{}={}'.format( name, NTOSPEED[ data ] ))
            else:
                g.append( '{}={:x}'.format( name, data ))
        return str.join( ':', g )


    def restore( self, saved ):
        ga = saved.split( ':' )
        fn_name = '_restore_{}'.format( ga.pop( 0 ) )
        fn = getattr( self, fn_name, None )
        if callable( fn ):
            fn( ga )


    def _restore_gpysttyc( self, ga ):
        attr = self.tcgetattr()
        cchar = attr[ TC_CC ]
        for n, data in enumerate( ga ):
            if n >= TC_CC:
                cchar[ n - TC_CC ] = str.encode( chr( int( data, base=16 )))
            else:
                attr[ n ] = int( data, base=16 )
        return self.tcsetattr()


    def _restore_gpysttyv( self, ga ):
        attr = self.tcgetattr()
        cchar = attr[ TC_CC ]
        gd = { k : v for k, v in ( p.split( '=' ) for p in ga ) }
        for k, v in gd.items():
            if k in CC_PARAM:
                pos = CC_PARAM[ k ][ CC_PARAM_POS ]
                cchar[ pos ] = str.encode( chr( int( v, base=16 )))
            elif k in ['ispeed', 'ospeed']:
                field = FLAG_LABEL[ k ]
                attr[ field ] = SPEED[ v ]
            elif k in FLAG_LABEL:
                field = FLAG_LABEL[ k ]
                attr[ field ] = int( v, base=16 )
        return self.tcsetattr()


def intconv( arg ):
    if isinstance( arg, int ): return arg
    l = len( arg )
    if l > 1:
        c2 = arg[0:2]
        if   c2 in ( '0x', '#x', '\\x' ): return int( arg[2:], base=16 )
        elif c2 in ( '0o', '#o', '\\0' ): return int( arg[2:], base= 8 )
        elif c2 in ( '0b', '#b', '\\b' ): return int( arg[2:], base= 2 )
        elif c2[0] == '\\' and l == 4:    return int( arg[1:], base= 8 )
        elif all( c in '0123456789' for c in arg ): return int( arg )
    elif     all( c in '0123456789' for c in arg ): return int( arg )
    return None


stdowidth = 75

def stdocols( fd=sys.stdout ):
    tty = Stty( fd=fd )
    try:
        width = tty.getwinsz( fd=fd )[1]
        return width if width > 0 else stdowidth
    except (IOError, IndexError):
        return stdowidth


def fold( flags, maxlen=stdowidth, indent=0, sep=' ' ):
    lines   = []
    current = []
    flags = list( flags[:] ) # copy tuple or list

    # maxlen must be at least wide enough for 1 value per line
    maxlen = max( maxlen - indent,
                  max( (1 + len( f )) for f in flags ))
    while flags:
        current.append ( flags.pop( 0 ) )
        text = sep.join( current )
        if len( text ) >= maxlen:
            flags.insert( 0, current.pop() ) # put it back
            lines.append( sep.join( current ) )
            current = []
    if current:
        lines.append( sep.join( current ) )
    linesep = '\n' + ' ' * indent
    return linesep.join( lines )


dispchar_special = {
    0x09  :   'TAB', # '\\t',
    0x1d  :   'RET', # '\\r', 'CR',
    0x1b  :   'ESC', # '\\e',
    0x20  :   'SPC', # less ambiguous than a blank
    0x7f  :   'DEL',
    0x89  : 'M-TAB',
    0x8d  : 'M-RET',
    0x9b  : 'M-ESC',
    0xa0  : 'M-SPC',
    0xff  : 'M-DEL',
}

def dispchar( c, args=None ):
    cm = 'C-M-' # "C-M-a" - Emacs convention
    disp_special = dispchar_special
    try:
        if not args.emacs:
            disp_special = {}
            cm  = 'M-^' # "M-^A"  - BSD and GNU stty convention
    except AttributeError:
        pass
    n = ord( c )
    if n == PC_VDISABLE  : return '<undef>'
    if n in disp_special : return disp_special[ n ]
    if        n  < 0x20  : return '^'  + chr( n ^ 0b01000000 )
    if        n == 0x7f  : return '^'  + chr( n ^ 0b01000000 )
    if 0x7f < n  < 0xa0  : return cm   + chr( n ^ 0b11000000 )
    if 0x9f < n  < 0xff  : return 'M-' + chr( n ^ 0b10000000 )
    if        n == 0xff  : return cm   + chr( n ^ 0b11000000 )
    else                 : return chr( n )


def make_display_values( tty, args ):
    ispeed = NTOSPEED[ tty.getispeed() ]
    ospeed = NTOSPEED[ tty.getospeed() ]
    line1 = []
    if ispeed == ospeed:
        line1.append( ( 'speed', ospeed) )
    else:
        line1.append( ('ispeed', ispeed) )
        line1.append( ('ospeed', ospeed) )

    if args.all:
        try:
            winsz = tty.getwinsz()
            line1.append(    ('rows', winsz[ WS_ROW ]) )
            line1.append( ('columns', winsz[ WS_COL ]) )
            if winsz[ WS_XPIXEL ] != 0 or winsz[ WS_YPIXEL ] != 0:
                line1.append( ('xpixels', winsz[ WS_XPIXEL ]) )
                line1.append( ('ypixels', winsz[ WS_YPIXEL ]) )
        except IOError:
            pass

    _, ldisc_iton = tty.ldisc_name_maps()
    ldisc = tty.getldisc()
    if ldisc is not None:
        if ldisc > 0 and ldisc in ldisc_iton:
            line1.append( ('line', ldisc, ldisc_iton[ ldisc ]) )
        else:
            line1.append( ('line', ldisc) )
    # Don't report cline unless it actually differs from ldisc,
    # because it's not functional anyway. (see tty.setcline)
    cline = tty.getcline()
    if cline is not None and cline != ldisc:
        if cline > 0 and cline in ldisc_iton:
            line1.append( ('c_line', cline, ldisc_iton[ cline ]) )
        else:
            line1.append( ('c_line', cline) )

    char = []
    for elt in CC_PARAM_LIST:
        if elt[ CC_PARAM_LIST_POS ] is False:
            continue  # not defined on this platform
        name = elt[ CC_PARAM_LIST_NAME ]
        try:
            val = tty.getcc( elt[ CC_PARAM_LIST_POS ] )
        except TypeError: # name not defined on this platform
            continue
        if not args.all:
            dfl = elt[ CC_PARAM_LIST_DFLT ]
            if dfl is None or ord( val ) == dfl:
                continue
        if name in ['time', 'min']:
            try:
                val = ord( val )
            except TypeError: # sometimes already an int
                pass
        else:
            val = dispchar( val, args )
        char.append( (name, val) )

    values = [ [] for x in (TC_IFLAG, TC_OFLAG, TC_CFLAG, TC_LFLAG) ]
    for elt in FLAG_LIST:
        name        = elt[ FLL_NAME ]
        tc_xflag    = elt[ FLL_XFLAG ]
        xflag_value = values[ tc_xflag ]
        mask        = elt[ FLL_FIELD ]
        masked_val  = elt[ FLL_FIELD_VALUE ]
        if mask is False or masked_val is False:
            continue # not defined on this platform
        if masked_val is None: # boolean flag
            if tty.Xflag( tc_xflag, mask ):
                xflag_value.append( name )
            else:
                xflag_value.append( '-' + name )
        else:                  # bit flag
            current = tty.Xflag( tc_xflag, mask )
            if current == masked_val:
                xflag_value.append( name )
    return ( line1, char, values )


def format_display_values( data, args ):
    def maxlen( array, validcol ):
        valid = [ x[ validcol ] for x in array if x is not None ]
        return max( len( x[ 0 ] ) for x in valid )

    line1, char, values = data
    for i, e in enumerate( line1 ):
        fmt = '{} = {} ({});' if (len( e ) > 2) else '{} = {};'
        line1[ i ] = fmt.format( *e )

    if char:
        if args.align and not args.wide:
            l = max( len( c[0] ) for c in char )
            fmt = '{{:<{}}} = {{:<8}} '.format( l ).format
        else:
            fmt = '{} = {}'.format
        char = [ fmt( elt[0], str( elt[1] ) + ';' ) for elt in char ]

    if args.align:
        # for diff_against_sane, some slots in values may be empty
        l = max( max( len( f ) for f in flag ) for flag in values if flag)
        fmt = '{{:<{}}}'.format( l ).format
        for i, xflag in enumerate( values ):
            new = []
            for elt in xflag:
                if elt[0] != '-':
                    elt = ' ' + elt
                new.append( fmt( elt ) )
            values[ i ] = new
    return ( line1, char, values )


def display_all( tty, args ):
    line1, char, values = format_display_values(
        make_display_values( tty, args ),
        args )
    values.append( char )
    width = stdocols()
    print( ' '.join( line1 ))
    labels = ('iflags', 'oflags', 'cflags', 'lflags', 'cchars')
    for label, flags in zip( labels, values ):
        if args.wide:
            text = str.join( ' ', flags )
        else:
            indent = 2 + len( label )
            text = fold( flags, maxlen=width, indent=indent )
        print( label, text, sep=': ' )


# Traditional bsd "stty everything" format of chars.
def display_bsd( tty, args ):
    dv = make_display_values( tty, args )
    line1, ignore,  values = format_display_values( dv, args )

    width = stdocols()
    print( ' '.join( line1 ))
    labels = ('iflags', 'oflags', 'cflags', 'lflags')
    for label, flags in zip( labels, values ):
        if args.wide:
            text = str.join( ' ', flags )
        else:
            indent = 2 + len( label )
            text = fold( flags, maxlen=width, indent=indent )
        print( label, text, sep=': ' )

    cnam, cval = zip(*dv[1])
    cwidth = max( len( x ) for x in cnam )
    fmt = '{{:<{}}}'.format( cwidth + 1 ).format
    c1 = [ fmt( x ) for x in cnam ]
    c2 = [ fmt( x ) for x in cval ]

    if args.wide:
        print( *c1 )
        print( *c2 )
    else:
        cl1 = fold( c1, maxlen=width ).split( '\n' )
        cl2 = fold( c2, maxlen=width ).split( '\n' )
        for pair in zip( cl1, cl2 ):
            print( pair[0] )
            print( pair[1] )


def display_flags( tty, args, flag_group ):
    _, _, values = make_display_values( tty, args )
    flagset = values[ FLAG_LABEL[ flag_group ] ]
    for elt in flagset:
        if elt[0] == '-':  print(     elt )
        else:              print( '', elt )


def display_cchars( tty, args ):
    args.all = True
    _, cchars, _ = make_display_values( tty, args )
    width = max( len( elt[0] ) for elt in cchars )
    for elt in cchars:
        print( '{:<{width}} = {}'.format( *elt, width=width ))


def display_bits( tty, args ):
    attr = tty.tcgetattr()

    wb = 8
    while any( (fl != (fl & ((1 << wb) - 1) )) for fl in attr[:-1] ): wb += 8
    wo = 1 + wb // 3
    wx = wb // 4

    if args.wide:
        try:
            _support = True
            '{:#_b}'.format( 0 )
        except ValueError:
            _support = False
    if args.wide and _support:
        wb += (wb//4) - 1
        wo += (wo//3)
        wx += (wx//8)
        fmt = ('{0}', 'b: {1:0{4}_b}', 'o: {1:0{3}_o}', 'x: {1:0{2}_x}')
    else:
        fmt = ('{0}', 'b: {1:0{4}b}',  'o: {1:0{3}o}',  'x: {1:0{2}x}' )

    fmt = '    '.join( fmt )
    for i, fl in enumerate( attr[:-1] ):
        name = FLAG_LABEL[ i ]
        print( fmt.format( name, fl, wx, wo, wb ))


def diff_against_sane( tty, args ):
    line1, char, values = make_display_values( tty, args )
    sanelist = ALIAS[ 'sane' ]
    for xflag in values:
        for sane in sanelist:
            try:
                xflag.remove( sane )
            except ValueError:
                pass
        for elt in list( xflag ):
            if tty.sane_default( elt ) is None:
                xflag.remove( elt )
    line1, char, values = format_display_values( (line1, char, values), args )

    values.append( char )
    width = stdocols()
    print( ' '.join( line1 ))
    labels = ('iflags', 'oflags', 'cflags', 'lflags', 'cchars')
    for label, flags in zip( labels, values ):
        if not flags:
            continue
        if args.wide:
            text = str.join( ' ', flags )
        else:
            indent = 2 + len( label )
            text   = fold( flags, maxlen=width, indent=indent )
        print( label, text, sep=': ' )


# Modified from original not to split single-char prefix options into separate one-letter args.
# That is, "-echo" is not shorthand for "-e -c -h -o".
# This means that all actual single-letter options must be specified independently.
class ArgParser( argparse.ArgumentParser ):
    def _get_option_tuples(self, option_string):
        result = []
        chars = self.prefix_chars
        if option_string[0] in chars and option_string[1] in chars:
            if '=' in option_string:
                option_prefix, explicit_arg = option_string.split('=', 1)
            else:
                option_prefix = option_string
                explicit_arg = None
            for option_string in self._option_string_actions:
                if option_string.startswith(option_prefix):
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, explicit_arg
                    result.append(tup)
        elif option_string[0] in chars and option_string[1] not in chars:
            option_prefix = option_string
            explicit_arg = None
            short_option_prefix = option_string[:2]
            short_explicit_arg  = option_string[2:]
        else:
            self.error(_('unexpected option string: %s') % option_string)
        return result


def get_args():
    help = {
        'file'     : 'open and use the specified DEVICE instead of stdin',
        'all'      : 'print all current settings in human-readable form',
        'bsd'      : 'print all current settings in traditional BSD'
                     ' "all" and "everything" formats',
        'save'     : 'print all current settings in stty-readable form',
        'emacs'    : 'Display characters in Emacs notation',
        'ctlchars' : 'Display characters in control char notation',
        'align'    : 'Align output into columns',
        'wide'     : 'Do not wrap lines',
        'verbose'  : 'Extended output', }

    p = ArgParser( description='Print or change terminal characteristics.' )
    p.add_argument( '-F', '-f', '--file', dest='device', default=sys.stdin,    help=help['file'])
    p_x = p.add_mutually_exclusive_group()
    p_x.add_argument( '-a',  '--all',      action='store_true', default=False, help=help['all'] )
    p_x.add_argument( '-e',  '--bsd',      action='store_true', default=False, help=help['bsd'] )
    p_x.add_argument( '-g',  '--save',     action='store_true', default=False, help=help['save'] )
    p_x2 = p.add_mutually_exclusive_group()
    p_x2.add_argument( '-E', '--emacs',    action='store_true', default=False, help=help['emacs'] )
    p_x2.add_argument( '-C', '--ctlchars', action='store_true', default=False, help=help['ctlchars'])
    p.add_argument(    '-c', '--align',    action='store_true', default=False, help=help['align'] )
    p.add_argument(    '-w', '--wide',     action='store_true', default=False, help=help['wide'] )
    p.add_argument(    '-v', '--verbose',  action='store_true', default=False, help=help['verbose'] )

    args, unknown = p.parse_known_args()
    args.setting = unknown
    return args

def main():
    args = get_args()
    tty = Stty( fd=args.device )

    showable_args = [
        'speed', 'ispeed', 'ospeed', 'line',   'ldisc',  'cline',  'c_line',
        'size',  'chars',  'cchars', 'iflags', 'oflags', 'cflags', 'lflags',
        'bits', ]
    showable_args.extend( TERMSZ.keys() )

    try:
        arg1 = args.setting[ 0 ]
        slen = len( args.setting )
    except IndexError:
        arg1 = None
        slen = 0

    if args.all:
        display_all( tty, args )
    elif args.bsd or arg1 in ['all', 'everything']:
        args.all = args.bsd = True
        display_bsd( tty, args )
    elif args.save:
        print( tty.save( verbose=args.verbose ) )

    elif not args.setting:
        diff_against_sane( tty, args )

    elif arg1.find( 'gpystty' ) == 0:
        tty.restore( arg1 )

    elif slen == 1 and arg1 in showable_args:
        if arg1.find( 'speed' ) in (0, 1):
            ispeed = NTOSPEED[ tty.getispeed() ]
            ospeed = NTOSPEED[ tty.getospeed() ]
            if   arg1 in ('ispeed',): print( ispeed )
            elif arg1 in ('ospeed',): print( ospeed )
            elif ispeed == ospeed:    print( ospeed )
            else:                     print( ispeed, ospeed )

        elif arg1 in ('size',) or arg1 in TERMSZ.keys():
            winsz = tty.getwinsz()
            if arg1 in ('size',):
                res = [ winsz[ WS_ROW ], winsz[ WS_COL ] ]
                if winsz[ WS_XPIXEL ] or winsz[ WS_YPIXEL ]:
                    res.extend( winsz[ WS_XPIXEL ], winsz[ WS_YPIXEL ] )
                print( *res )
            elif arg1 in termsz_rows: print( winsz[ WS_ROW ] )
            elif arg1 in termsz_cols: print( winsz[ WS_COL ] )
            elif arg1 in termsz_xpix: print( winsz[ WS_XPIXEL ] )
            elif arg1 in termsz_ypix: print( winsz[ WS_YPIXEL ] )

        elif arg1 in ('line', 'ldisc'):
            print( tty.getldisc() )

        elif arg1 in ('cline', 'c_line'):
            cline = tty.getcline()
            if cline is None:
                cline = tty.getldisc()
            print( cline )

        elif arg1 in ('iflags', 'oflags', 'cflags', 'lflags'):
            display_flags( tty, args, arg1 )

        elif arg1 in ('chars', 'cchars' ):
            display_cchars( tty, args )

        elif arg1 in ('bits',):
            display_bits( tty, args )

        else:
            raise Exception( 'This should not happen' )
    else:
        tty.tcgetattr( reset=True )
        # Expand any aliases
        settings = []
        for arg in args.setting:
            if arg in ALIAS:
                settings.extend( ALIAS[ arg ] )
            else:
                settings.append( arg )

        while settings:
            arg = settings.pop( 0 )
            if arg in SPEED:
                tty.setispeed( arg )
                tty.setospeed( arg )
            elif arg in ('ispeed', 'ospeed', 'speed'):
                speed = settings.pop( 0 )
                if arg[0] in ('i', 's'): tty.setispeed( speed )
                if arg[0] in ('o', 's'): tty.setospeed( speed )
            elif intconv( arg ) is not None:
                # If it's not in SPEED, it's not valid,
                # but let this method do the admonition.
                tty._chkspeed( arg )

            elif arg in CC_PARAM:
                param = CC_PARAM[ arg ]
                tty.setcc ( param[ 0 ], settings.pop( 0 ) )

            elif arg in TERMSZ:
                size = int( settings.pop( 0 ) )
                winsz = tty.getwinsz()
                winsz[ TERMSZ[ arg ] ] = size
                tty.setwinsz()

            elif arg in ( 'line', 'ldisc', 'cline', 'c_line' ):
                disc = settings.pop( 0 )
                try:
                    disc = int( disc )
                except (TypeError, ValueError):
                    ntoi, iton = tty.ldisc_name_maps()
                    if disc.lower() in ntoi:
                        disc = ntoi[ disc.lower() ]
                if arg in ['cline', 'c_line'] and tty.getcline() is not None:
                    tty.setcline( disc )
                else:
                    tty.setldisc( disc )

            else:
                tty.setflag( arg )
        tty.tcsetattr()
        if args.verbose:
            args.all = args.verbose
            display_all( tty, args )


if __name__ == '__main__':
    main ()

# eof
