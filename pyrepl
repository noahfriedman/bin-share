#!/usr/bin/env python
# pyrepl --- interactive python interpreter with easier to read output

# Author: Noah Friedman <friedman@splode.com>
# Created: 2018-09-05
# Public domain

# Commentary:
# Code:

# Copy namespace now, before any modules are imported.
repl_locals = dict( locals() )

import readline
import rlcompleter
import code
import subprocess

import atexit
import os
import platform
import pprint
import sys


# Provide saved history and tab completion on python symbols
# Shamelessly stolen from Python library manual
class Repl( code.InteractiveConsole ):
    def __init__( self, locals=None, histfile=None ):
        code.InteractiveConsole.__init__( self, locals )

        if histfile is None:
            histdir  = os.getenv( 'XDG_CACHE_HOME' ) or os.getenv( 'HOME' )
            histfile = os.path.join( histdir, ".pyrepl_history" )
        self.init_history( histfile )

    def init_history(self, histfile):
        readline.parse_and_bind( 'tab: complete')
        try:
            readline.read_history_file( histfile )
            atexit.register( self.save_history, histfile )
        except IOError:           # python2
            pass
        except FileNotFoundError: # python3, undef in python2
            pass

    def save_history( self, histfile ):
        readline.set_history_length( 1024 )
        readline.write_history_file( histfile )

class ReplPrettyPrinter( pprint.PrettyPrinter ):
    # This method override adds padding so that all keys in a dict are
    # aligned to the same column. That is, they are all indented to the
    # length of the longest key.
    def _format_dict_items( self, items, stream, indent, allowance, context, level ):
        items_repr = [ (self._repr( key, context, level), ent) for key, ent in items ]
        max_keylen = max( len( elt[0] ) for elt in items_repr ) + 1

        write      = stream.write
        indent    += self._indent_per_level
        delimnl    = ',\n' + ' ' * indent
        last_index = len( items_repr ) - 1

        for i, (rep, ent) in enumerate( items_repr ):
            last = i == last_index
            write( rep )
            write( ' ' * (max_keylen - len( rep )))
            write( ': ' )
            self._format( ent,
                          stream,
                          indent + max_keylen + 2,
                          allowance if last else 1,
                          context,
                          level )
            if last:
                write( delimnl[ 0 : -self._indent_per_level ])
            else:
                write( delimnl )


repl_pp = ReplPrettyPrinter( indent=2, width=60 )
def pp( *args, **kwargs ):
    for arg in args:
        repl_pp.pprint( arg, **kwargs )

def bt( *cmd ):
    output = subprocess.check_output( cmd ).decode( sys.stdout.encoding )
    return output.rstrip( ' \t\r\n' )

def load( filename ):
    with open( filename, 'r' ) as f:
        text = f.read()
    text.replace( '\r\n', '\n' )
    exec( text, repl_locals )

def pyrepl():
    banner = '{} {}.{}.{} [{}] {}-{}'.format(
        platform.python_implementation(),
        sys.version_info.major,
        sys.version_info.minor,
        sys.version_info.micro,
        platform.python_build()[1],
        sys.platform,
        platform.machine(), )

    # Keep the initial namespace of the repl fairly clean,
    # except for some convenience functions.
    # (having access to repl_pp lets us change _width on occasion.
    # Set the current namespace to __pyrepl__ so loading random
    # scripts doesn't fire off their "if __main__" blocks.
    repl_locals.update( { '__name__' : '__pyrepl__',
                          'bt'       : bt,
                          'load'     : load,
                          'repl_pp'  : repl_pp, } )

    # Don't display 'None' if there is nothing to display.
    sys.displayhook = lambda arg: (arg is None) or pp( arg )
    repl = Repl( locals=repl_locals )
    try:
        repl.interact( banner=banner, exitmsg='' )
    except TypeError:
        repl.interact( banner=banner )  # python2.7

if __name__ == '__main__':
    pyrepl()

# pyrepl ends here
