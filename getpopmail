#! /bin/sh
# getpopmail --- retrieve POP mail

# Copyright (C) 1996 Noah S. Friedman

# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1996-02-27

# $Id: getpopmail,v 2.4 1996/07/27 02:14:28 friedman Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.

# Commentary:

# This program has some external program dependencies.
# 1) You must have `popclient' and `expect'.
# 2) If you use the --probe option, you need to write external script
#    called `network-up-p' which tests to see if the pop servers or network
#    in general are reachable.
#
# This script reads a configuration file with lines of the form
#
#     server : user : password : protocol : flags
#
# Where
#        `server is the pop server
#        `user'  is the user name on the pop server
#        `password' is the user's password on the pop server
#        `protocol' is the POP protocol used (either 2 or 3)
#        `flags' are additional flags to `popclient', e.g. `-k'.
#
# Anything after a `#' character in the configuration file is considered a
# comment.  Excess whitespace and blank lines are ignored.
#
# The configuration file can be specified with the `--config' option, the
# GETPOPMAILCF environment variable, or $HOME/.getpopmail.cf by default.

# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

usage="Usage: $progname {options}

Options are:
-D, --debug                  Enable debugging.
-c, --config    FILE         Use configuration file FILE.
-h, --help                   You're looking at it.
-p, --probe     {HOSTS}      Make sure pop server/gateway accessible first.
                             The optional argument ${bq}hosts$eq can be one
                             of ${bq}server$eq or ${bq}gateway$eq,
                             indicating that each pop server contacted
                             should be ${bq}ping${eq}ed prior to
                             contacting, or else the local routing gateway
                             should be pinged before attempting any
                             connections at all.
                             This is to avoid long delays waiting for
                             connections to time out for servers that are
                             down, or if running with transient PPP links.
                             If no argument is given, both are probed.
-q, --quiet                  Discard all output.
                             This is the default if stdin is not a tty.
-v, --verbose                Be verbose.
                             This is the default if stdin is a tty.
"

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.

PATH="$PATH:/usr/local/bin"
export PATH

GETPOPMAILCF=${GETPOPMAILCF-$HOME/.getpopmail.cf}
export GETPOPMAILCF

debug=
probe=

if [ -t 0 ]; then
  verbose=t
else
  verbose=
fi

# Usage: eval "$getopt"; value=$optarg
# or     optarg_optional=t; eval "$getopt"; value=$optarg
#
# This function automatically shifts the positional args as appropriate.
# The argument to an option is optional if the variable `optarg_optional'
# is non-empty.  Otherwise, the argument is required and getopt will cause
# the program to exit on an error.  optarg_optional is reset to be empty
# after every call to getopt.  The argument (if any) is stored in the
# variable `optarg'.
#
# Long option syntax is `--foo=bar' or `--foo bar'.
# For optional args, you must use the `--foo=bar' long option syntax
# if the argument starts with `-', otherwise the argument will be ignored
# and treated as the next option.
#
# Note: because of broken bourne shells, using --foo=bar syntax can
# actually screw the quoting of args that end with trailing newlines.
# Specifically, most shells strip trailing newlines from substituted
# output, regardless of quoting.
getopt='
  {
    optarg=
    case "$1" in
      --*=* ) optarg=`echo "$1" | sed -e "1s/^[^=]*=//"` ; shift ;;
      -* )
        case "${2+set}:$optarg_optional" in
          set: ) optarg="$2" ; shift ; shift ;;
          set:?* )
            case "$2" in
              -* ) shift ;;
              * )  optarg="$2"; shift; shift ;;
            esac
           ;;
          : )
            option="$1"
            case "$option" in
              --*=* ) option=`echo "$option" | sed -e "1s/=.*//;q"` ;;
            esac
            echo "$progname: option $bq$option$eq requires argument." 1>&2
            echo "$progname: use $bq--help$eq to list option syntax." 1>&2
            exit 1
           ;;
          * ) shift ;;
        esac
       ;;
    esac
    optarg_optional=
  }'

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while : ; do
  case $# in 0) break ;; esac
  case "$1" in
    -D | --debug | --d* )
      debug=-d
      shift
     ;;
    # Provided as an example of how to process options with arguments
    -c | --config* | --c* )
      eval "$getopt"
      GETPOPMAILCF="$optarg"
     ;;
    -h | --help | --h* )
      echo "$usage" 1>&2
      exit 0
     ;;
    -p | --probe* | --p* )
      probe=t
      optarg_optional=t
      eval "$getopt"

      case "$optarg" in
        server | gateway | gw ) probe="$optarg" ;;
        ""       ) : ;;
        * )
          # Not a recognized arg to --probe; push arg back onto arglist.
          set fnord "$optarg" ${1+"$@"}
          shift
         ;;
      esac
     ;;
    -q | --quiet | --q* )
      verbose=
      shift
     ;;
    -v | --verbose | --v* )
      verbose=t
      shift
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -? | --* )
      case "$1" in
        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
        * )     arg="$1" ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    -??* )
      # Split grouped single options into separate args and try again
      optarg="$1"
      shift
      set fnord `echo "x$optarg" | sed -e 's/^x-//;s/\(.\)/-\1 /g'` ${1+"$@"}
      shift
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in -d ) set -x ;; esac

case "$verbose" in
  t ) : ;;
  * ) exec > /dev/null 2>&1 < /dev/null ;;
esac

case "$probe" in t | gw | gateway )
  network-up-p -v || exit $? ;;
esac

exec 3< "$GETPOPMAILCF" || exit $?

while read x 0<&3; do

    case "$x" in
      '#'* | '' ) continue ;;
      *'#'* )     x=`echo "$x" | sed -e 's/#.*//'` ;;
    esac

    oIFS="$IFS"
    IFS=":"
    set fnord $x
    IFS="$oIFS"

    set $*
    shift

    server=$1 user=$2 pass=$3 protocol=$4
    shift; shift; shift; shift

    case "$probe" in t | server )
      network-up-p -v "$server" || continue ;;
    esac

    expect -f - <<__EOF__
      spawn popclient -u "$user" "-v$protocol" ${1+"$@"} "$server"
      expect "password:"
      send "$pass\r"
      set timeout 15
      expect {
        timeout {
          puts "(connection timed out)"
          exit
        }
        "+OK"
      }
      set timeout -1
      expect eof
__EOF__
done

# eof
