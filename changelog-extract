#!/bin/sh
# changelog-extract --- extract entries from ChangeLog files
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1993-03-26
# Public domain

# $Id$

# Comments:

# Usage: changelog-extract {--regexp} entry1 entry2 ... < ChangeLog
#        cat ChangeLog1 ChangeLog2 ... | changelog-extract ...
#
# --regexp [-r] option means entryN are regular expressions instead of
# exact patterns.

# Code:

# Name by which this script was invoked.
progname=`echo "$0" | sed -e 's/[^\/]*\///g'`

# To prevent hairy quoting and escaping later.
bq='`'
eq="'"

usage="Usage: $progname {options} [entry1] {entry2 {...}}

Options are:
-D, --debug                  Turn on shell debugging ($bq${bq}set -x$eq$eq).
-f, --file     CHANGELOG     Read entries from CHANGELOG file.  There may
                             be multiple instances of this option.
-h, --help                   You're looking at it.
-r, --regexp                 Entries are regular expressions, not literal text.
"

# Initialize variables.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
debug=
regexp=nil

# Usage: filename=foo; eval "$save_filename"
#        eval "$restore_filename"
_saved_args=
_saved_args_index=0
save_filename='
  {
    eval _saved_args$_saved_args_index=\$filename
    _saved_args="$_saved_args \"\$_saved_args$_saved_args_index\""
    _saved_args_index=`expr $_saved_args_index + 1`
  }'
restore_filenames='
  {
    eval '\''{ eval set fnord $_saved_args ; }'\''
    shift
  }'

# Usage: value=`(set - "$1" "$2"; eval "$get_option_argument")`
#
# Long option syntax is `--foo=bar' or `--foo bar'.  2nd argument ARG
# won't get used if first long option syntax was used.
# If 3rd argument OPTIONAL is set, then 2nd may be empty without resulting
# in an error (i.e. option argument is optional)
#
# Returns number of positions caller should shift.
# If retval = 3, caller should exit.
get_option_argument='
  {
    option="$1" arg="$2" arg_optional="$3" shift_num=2
    case "$option" in
      --*=* )
        arg=`echo $option | sed -e "s/^[^=]*=//"`
        shift_num=1
       ;;
    esac
    case "$arg" in
      "" )
        case "$arg_optional" in
          "" )
            case "$option" in
              --*=* ) option=`echo $option | sed -e "s/=.*//"` ;;
            esac
            echo "$progname: option $bq$option$eq requires argument." 1>&2
            echo "$usage" 1>&2
            exit 3
           ;;
        esac
        exit 1
       ;;
    esac
    echo "$arg"
    exit $shift_num
  }'

# Some bourne shells don't allow a numeric argument to `shift'.
# Usage: eval "shift_num=n; $shift_n_times"
shift_n_times='
  {
    while : ; do
      case "$shift_num" in 0 | "" ) break ;; esac
      shift_num=`expr $shift_num - 1`
      shift
    done
  }'

# Parse command line arguments.
# Make sure that all wildcarded options are long enough to be unambiguous.
# It's a good idea to document the full long option name in each case.
# Long options which take arguments will need a `*' appended to the
# canonical name to match the value appended after the `=' character.
while : ; do
  case $# in 0) break ;; esac
  case "$1" in
    -D | --debug | --d* )
      debug=t
      shift
     ;;
    -h | --help | --h )
      echo "$usage" 1>&2
      exit 1
     ;;
    # Provided as an example of how to process options with arguments
    -f | --file* | --f* )
      filename=`(set - "$1" "$2"; eval "$get_option_argument")`
      retval=$?
      case $retval in 3 ) exit 1 ;; esac
      eval "shift_num=$retval; $shift_n_times"
      eval "$save_filename"
     ;;
    -r | --regexp | --r* )
      regexp=t
      shift
     ;;
    -- )     # Stop option processing
      shift
      break
     ;;
    -* )
      case "$arg" in
        --*=* ) arg=`echo $1 | sed -e 's/=.*//'` ;;
        * )     arg=$1 ;;
      esac
      exec 1>&2
      echo "$progname: unknown or ambiguous option $bq$arg$eq"
      echo "$progname: Use $bq--help$eq for a list of options."
      exit 1
     ;;
    * )
      break
     ;;
  esac
done

case "$debug" in t ) set -x ;; esac

case $# in
  0 )
    cat
    exit $?
   ;;
esac

case "$regexp" in
  t ) sed_re_quote='s/\([][*.\?+&|^$]\)/\\\1/g;' ;;
  * ) sed_re_quote= ;;
esac

sed_file_quote='s=/=\\/=g;'
sed_gather='H
            ${
               x
               s/^\n//
               s/\n/|/g
               /|/s/\(.*\)/(\1\)/
               p
             }'

re_filenames=`
  {
    for f in ${1+"$@"} ; do 
      echo "$f"
    done
  } | sed -ne "$sed_re_quote
               $sed_file_quote
               $sed_gather"
 `

eval "$restore_filenames"

${AWK-awk} '
     BEGIN {
        ChangeLog_entry = "";
        old_ChangeLog_entry = "";
        entry_found="";
        lines_index = 0;
        lines["array_initializer"] = "" ;
        delete lines["array_initializer"];
     }

     /^[^ \t]/ {
        old_ChangeLog_entry = ChangeLog_entry;
        ChangeLog_entry = $0;
        next;
     }

     /(^$)|(^[ \t]*$)/ {
        if (entry_found) {
           if (ChangeLog_entry != old_ChangeLog_entry) {
             print ChangeLog_entry "\n";
             old_ChangeLog_entry = ChangeLog_entry;
           }
           for (i = 0; i < lines_index ; i++)
              print lines[i];
           print "";
        }
        for (i in lines)
           delete lines[i];
        entry_found="";
        lines_index=0;
        next;
     }

     /^[ \t][ \t]*[^ \t]/ {
        lines[lines_index] = $0;
        lines_index++;
     }

     /[ \t,]'"$re_filenames"'([ \t,].*:|:)/ { 
        entry_found="yes"; 
        next; 
     }' ${1+"$@"}

# changelog-extract ends here
