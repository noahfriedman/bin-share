#!/usr/local/gnubin/bash
# forward-mail --- forward spooled mail to foreign recipient
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1992-12-18
# Public domain

# $Id$

# Commentary:

# Spool file will be deleted after mail is sent.
# Requires bash 1.12 or later to work properly. 

# Code:

function usage ()
{
    if [ $# -gt 0 ]; then
       echo -e "${progname}: $*\n" 1>&2
    fi

    cat 1>&2 << __EOF__
Usage: ${progname} {options}

Options are:
-D, --debug                  Turn on shell debugging ("set -x").
-e, --errors-to  MAINTAINER  Stderr is reported to maintainer via email.
                             If MAINTAINER is set to "maintainer",
                             "$default_maintainer" is used.
-f, --file       FILE        Name of spool file to forward.  
-h, --help                   You're looking at it.
-s, --spool-file FILE        Same as -f (--file).
-r, --recipient  ADDR        Address to send forwarded mail.
-t, --to         ADDR        Same as -r (--recipient).
__EOF__

    exit 1
}

function main ()
{
 local file

    initialize_variables "$@"
    parse_command_args "$@"
    shift $?

    test -n "${debug+set}" && set -x

    if [ -z "${recipient}" -o -z "${file}" ]; then
       usage "recipient and spool-file must be specified."
    fi

    # It's ok for the file not to exist or to be empty; in that case
    # there's simply nothing to forward.
    { test -e "${file}" && test -s "$file" ; } || exit 0
   
    movemail "${file}" "${file}$$" || exit 1
    send_mail "${recipient}" < "${file}$$" && rm -f "${file}$$"
}

function initialize_variables ()
{
    progname="${0##*/}"
    progname_arguments="$*"

    bq="\`"  # To prevent hairy quoting and escaping later.
    eq="'"

    # Make sure PATH includes location of sendmail and movemail.
    PATH="/usr/local/gnubin:/usr/local/lib/emacs/etc:${PATH}:/usr/lib"

    umask 000

    TRAP_SIGNALS="EXIT SIGHUP SIGINT SIGQUIT SIGTERM"
    trap 'cleanup_and_exit' ${TRAP_SIGNALS}

    hostname="$(hostname)"

    default_maintainer="friedman"
    maintainer="${default_maintainer}"
}

function parse_command_args ()
{
 local orig_number_options=$#

    # unset option variables to make sure they weren't accidentally
    # exported 
    unset debug stderr_file file recipient

    # If you add new options be sure to change the wildcards below to make
    # sure they are unambiguous (i.e. only match one possible long option)
    # Be sure to show at least one instance of the full long option name to
    # document what the long option is canonically called. 
    # Long options which take arguments will need a `*' appended to the
    # canonical name to match the value appended after the `=' character. 
    while [ $# -gt 0 ]; do
       case z$1 in
          z-D | z--debug | z--d* )
             debug=t
             shift
            ;;
          z-e | z--errors-to* | z--e* )
             get_option_argument maintainer "$1" "$2"
             shift $?

             if [ "${maintainer}" = "maintainer" ]; then
                maintainer="${default_maintainer}"
             fi

             # Redirect all of stderr to a tmp file which we can mail
             # later. 
             stderr_file="/tmp/${progname}.stderr$$"
             exec 2> "${stderr_file}"
            ;;
          z-f | z-s | z--file* | z--spool-file* | z--f* | z--s* )
             get_option_argument file "$1" "$2"
             shift $?
            ;;
          z-h* | z--help | z--h* )
             usage
            ;;
          z-r | z-t | z--recipient* | z--to* | z--r* | z--t* )
             get_option_argument recipient "$1" "$2"
             shift $?
            ;;
          z-- )
             shift
             break
            ;;
          z-* )
             usage "${bq}${1}${eq} is not a valid option."
            ;;
          * )
             break
            ;;
       esac
    done

    # Return number of shifted arguments so calling function can shift
    # appropriate amount.
    return $[ orig_number_options - $# ]
}

# Usage: get_option_argument VARIABLE OPTION ARG {OPTIONAL}
#    where VARIABLE is shell variable that will be set to the value ARG.
#    Long option syntax is `--foo=bar' or `--foo bar'.  3rd argument ARG
#    won't get used if first long option syntax was used.  If 4 arg
#    OPTIONAL is non-empty, option isn't required to have an argument; if
#    the argument is missing, VARIABLE is set to the empty value. 
# Returns number of positions caller should shift
function get_option_argument ()
{
 local variable="$1"
 local option="$2"
 local arg="$3"
 local arg_optional="$4"

    # All long options must be at least 3 characters long (--o*), whereas
    # short options are only two chars (-o) and arguments are always
    # separate.
    if [ ${#option} -ge 3 -a "z${option#*=}" != "z${option}" ]; then
       arg="${option#*=}"  # Strip off anything before and including `=' char
       eval ${variable}=\'"${arg}"\'
       return 1
    else
       if [ -z "${arg}" -a -z "${arg_optional}" ]; then
          usage "option ${bq}${option}${eq} requires argument."
       fi
       eval ${variable}=\'"${arg}"\'
       return 2
    fi
}

function send_mail ()
{
 local recipient="$1"

    sendmail -oi -t <<- __EOF__
	From: ${progname} (Automated mail forwarder)
	To: ${recipient}
	Bcc: ${maintainer}
	Subject: Forwarded spooled mail from ${hostname}
	Reply-To: ${maintainer}
	Precedence: bulk
	
	$(cat)
	__EOF__
}

function mail_stderr_to_maintainer ()
{
    test -s "${stderr_file}" || return

    sendmail -oi -t <<- __EOF__
	From: ${progname} (Automated mail forwarder)
	To: ${maintainer}
	Subject: ${progname} stderr output
	Reply-To: ${maintainer}
	Precedence: bulk
	
	This is an automated report from ${hostname}. 
	With euid ${EUID} (ruid ${UID}), program "${progname}" ran with 
	the following arguments:
	
	   ${progname_arguments}
	
	and generated the following output on stderr:
	
	----------------------------------------
	$(cat "${stderr_file}")
	----------------------------------------
	__EOF__
}

cleanup_and_exit ()
{
 local exitstat="$?"

   # Reset traps to avoid double execution of this function when a signal
   # is caught (as opposed to normal exit).
   trap '' ${TRAP_SIGNALS}

   mail_stderr_to_maintainer
   rm -f "${stderr_file}" 2> /dev/null

   builtin exit ${exitstat}
}

main "$@"

# eof
